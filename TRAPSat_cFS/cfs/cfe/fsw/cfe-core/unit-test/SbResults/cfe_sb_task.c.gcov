        -:    0:Source:/home/wmoleski/CFS/mission_2014/cfe/fsw/cfe-core/src/sb/cfe_sb_task.c
        -:    0:Graph:cfe_sb_task.gcno
        -:    0:Data:cfe_sb_task.gcda
        -:    0:Runs:1
        -:    0:Programs:5
        -:    1:/******************************************************************************
        -:    2:** File: cfe_sb_task.c
        -:    3:**
        -:    4:**      Copyright (c) 2004-2012, United States government as represented by the
        -:    5:**      administrator of the National Aeronautics Space Administration.
        -:    6:**      All rights reserved. This software(cFE) was created at NASA's Goddard
        -:    7:**      Space Flight Center pursuant to government contracts.
        -:    8:**
        -:    9:**      This is governed by the NASA Open Source Agreement and may be used,
        -:   10:**      distributed and modified only pursuant to the terms of that agreement.
        -:   11:**
        -:   12:**
        -:   13:**
        -:   14:** Purpose:
        -:   15:**      This file contains the source code for the SB task.
        -:   16:**
        -:   17:** Author:   R.McGraw/SSI
        -:   18:**
        -:   19:** $Log: cfe_sb_task.c.gcov  $
        -:   19:** Revision 1.5 2015/06/24 12:19:49EDT wmoleski 
        -:   19:** Checking in the unit-test results for cFE 6.4.2.0
        -:   20:** Revision 1.18 2012/01/18 16:30:29GMT-05:00 jmdagost 
        -:   21:** Updated no-op event message to include cFE version numbers.
        -:   22:** Revision 1.17 2012/01/13 12:15:13EST acudmore 
        -:   23:** Changed license text to reflect open source
        -:   24:** Revision 1.16 2011/12/20 10:28:02EST rmcgraw 
        -:   25:** DCR15187:1 Changed MsgIdToPipeErrCnt to MsgLimErrCnt
        -:   26:** Revision 1.15 2009/07/17 18:07:33EDT aschoeni 
        -:   27:** Updated MsgMap and associated variables to be CFE_SB_MsgId_t
        -:   28:** Revision 1.14 2009/06/26 17:02:06EDT aschoeni 
        -:   29:** Updated SB to use __func__ instead of __FILE__ for lock and unlock errors
        -:   30:** Revision 1.13 2009/06/10 09:18:03EDT acudmore 
        -:   31:** Updated OS_Mem* and OS_BSP* to CFE_PSP_*
        -:   32:** Revision 1.12 2009/04/29 10:05:37EDT rmcgraw 
        -:   33:** DCR5801:11 Removed old code that was commented out
        -:   34:** Revision 1.11 2009/04/24 10:30:52EDT rmcgraw 
        -:   35:** DCR6772:1 Added #include cfe_es_msg.h
        -:   36:** Revision 1.10 2009/04/24 10:24:48EDT rmcgraw 
        -:   37:** DCR6772:1 Changed the Get/PutPoolBuf check in SB_AppInit
        -:   38:** Revision 1.9 2009/04/08 13:20:10EDT rmcgraw 
        -:   39:** DCR6772:1 Added insurance that a gnd cmded reset can get to ES
        -:   40:** Revision 1.8 2009/04/01 15:23:28EDT rmcgraw 
        -:   41:** DCR6296:4 Changed hk tlm point from pk-mem-inuse to unmarked mem
        -:   42:** Revision 1.7 2009/02/12 14:52:46EST rmcgraw 
        -:   43:** DCR6296:3 Remove 'Buf' in memory pool names
        -:   44:** Revision 1.6 2009/02/06 12:56:07EST rmcgraw 
        -:   45:** DCR5802:3 Removed two of four new telemetry items
        -:   46:** Revision 1.5 2009/02/05 16:19:53EST rmcgraw 
        -:   47:** DCR5802:2 Added SB statistics to hk pkt
        -:   48:** Revision 1.4 2009/02/03 11:07:01EST rmcgraw 
        -:   49:** DCR5801:2 Changed destination desciptors from array based to linked list
        -:   50:** Revision 1.3 2008/08/08 14:11:56EDT rjmcgraw 
        -:   51:** DCR4208:1 Added #include cfe_sb_verify.h to cfe_sb_task.c
        -:   52:** Revision 1.2 2008/07/31 15:41:34EDT apcudmore 
        -:   53:** Added execution counter API:
        -:   54:**   -- Added execution counter to ES internal task data
        -:   55:**   -- Added code to increment counter in RunLoop
        -:   56:**   -- Added code to report counter in GetInfo APIs
        -:   57:**   -- Added API to increment counter for child tasks
        -:   58:**   -- Added code to cFE Core apps to increment counters.
        -:   59:** Revision 1.1 2008/04/17 08:05:32EDT ruperera 
        -:   60:** Initial revision
        -:   61:** Member added to tlserver3
        -:   62:** Revision 1.62 2007/09/20 11:59:44EDT rjmcgraw 
        -:   63:** Fixed compiler error related to event log variable
        -:   64:** Revision 1.61 2007/09/04 16:22:50EDT rjmcgraw 
        -:   65:** Added code to detect number of active event filters in platform cfg file
        -:   66:** Revision 1.60 2007/07/12 17:01:37EDT rjmcgraw 
        -:   67:** Added code to process new SB event filtering params from platform cfg file
        -:   68:** Revision 1.59 2007/06/04 13:23:39EDT rjmcgraw 
        -:   69:** Moved SB stat initialization from task init to early init
        -:   70:** Revision 1.58 2007/05/18 16:12:11EDT rjmcgraw 
        -:   71:** DCR3052:9 Moved initialization of subscription report state from app init to 
        -:   72:** early init
        -:   73:** Revision 1.57 2007/05/16 15:13:40EDT dlkobe 
        -:   74:** Added MemPoolHandle members to HK packet
        -:   75:** Revision 1.56 2007/05/15 11:01:32EDT rjmcgraw 
        -:   76:** DCR78:11 Exit main loop for CFE_SB_RcvMsg errors
        -:   77:** Revision 1.55 2007/05/10 15:44:04EDT rjmcgraw 
        -:   78:** Added check of GetPipePtr return in SendRtgInfo
        -:   79:** Revision 1.54 2007/05/01 09:42:13EDT rjmcgraw 
        -:   80:** DCR3052:7 Removed function SendNetworkInfo
        -:   81:** Revision 1.53 2007/05/01 09:30:42EDT rjmcgraw 
        -:   82:** DCR3314:3 Populate subtype fields for SB files
        -:   83:** Revision 1.52 2007/04/30 15:20:34EDT rjmcgraw 
        -:   84:** DCR78:5 Removed delay, added sys log msg for cmd pipe errors
        -:   85:**
        -:   86:******************************************************************************/
        -:   87:
        -:   88:/* Include Files */
        -:   89:
        -:   90:#include "cfe_sb.h"
        -:   91:#include "cfe_sb_events.h"
        -:   92:#include "cfe_evs.h"
        -:   93:#include "cfe_sb_priv.h"
        -:   94:#include "osapi.h"
        -:   95:#include "cfe_version.h"
        -:   96:#include "cfe_msgids.h"
        -:   97:#include "cfe_error.h"
        -:   98:#include "cfe_es.h"
        -:   99:#include "cfe_psp.h"
        -:  100:#include "cfe_es_msg.h"
        -:  101:#include "cfe_sb_verify.h"
        -:  102:#include <string.h>
        -:  103:
        -:  104:/*  Task Globals */
        -:  105:cfe_sb_t                CFE_SB;
        -:  106:CFE_SB_Qos_t            CFE_SB_Default_Qos;
        -:  107:
        -:  108:
        -:  109:/******************************************************************************
        -:  110:**  Function:  CFE_SB_TaskMain()
        -:  111:**
        -:  112:**  Purpose:
        -:  113:**    Main loop for Software Bus task, used to process SB commands.
        -:  114:**
        -:  115:**  Arguments:
        -:  116:**    none
        -:  117:**
        -:  118:**  Return:
        -:  119:**    none
        -:  120:*/
        -:  121:void CFE_SB_TaskMain(void)
        2:  122:{
        -:  123:    int32  Status;
        -:  124:
        2:  125:    CFE_ES_PerfLogEntry(CFE_SB_MAIN_PERF_ID);
        -:  126:
        2:  127:    Status = CFE_SB_AppInit();
        -:  128:    
        2:  129:    if(Status != CFE_SUCCESS)
        -:  130:    {
        1:  131:      CFE_ES_WriteToSysLog("SB:Application Init Failed,RC=0x%08X\n", Status);
        1:  132:      CFE_ES_PerfLogExit(CFE_SB_MAIN_PERF_ID);
        -:  133:      /* Note: CFE_ES_ExitApp will not return */
        1:  134:      CFE_ES_ExitApp(CFE_ES_CORE_APP_INIT_ERROR);
        -:  135:    }/* end if */
        -:  136:
        -:  137:    /*
        -:  138:     * Wait for other apps to start.
        -:  139:     * It is important that the core apps are present before this starts receiving
        -:  140:     * messages from the command pipe, as some of those handlers might depend on
        -:  141:     * the other core apps.
        -:  142:     */
        2:  143:    CFE_ES_WaitForStartupSync(CFE_CORE_MAX_STARTUP_MSEC);
        -:  144:
        -:  145:    /* Main loop */
        5:  146:    while (Status == CFE_SUCCESS)
        -:  147:    {    
        -:  148:        /* Increment the Main task Execution Counter */
        1:  149:        CFE_ES_IncrementTaskCounter();
        -:  150:
        1:  151:        CFE_ES_PerfLogExit(CFE_SB_MAIN_PERF_ID);
        -:  152:
        -:  153:        /* Pend on receipt of packet */
        1:  154:        Status = CFE_SB_RcvMsg(&CFE_SB.CmdPipePktPtr,
        -:  155:                                CFE_SB.CmdPipe,
        -:  156:                                CFE_SB_PEND_FOREVER);
        -:  157:
        1:  158:        CFE_ES_PerfLogEntry(CFE_SB_MAIN_PERF_ID);
        -:  159:
        1:  160:        if(Status == CFE_SUCCESS)
        -:  161:        {
        -:  162:            /* Process cmd pipe msg */
    #####:  163:            CFE_SB_ProcessCmdPipePkt();
        -:  164:        }else{
        1:  165:            CFE_ES_WriteToSysLog("SB:Error reading cmd pipe,RC=0x%08X\n",Status);                  
        -:  166:        }/* end if */
        -:  167:
        -:  168:    }/* end while */
        -:  169:
        -:  170:    /* while loop exits only if CFE_SB_RcvMsg returns error */
        2:  171:    CFE_ES_ExitApp(CFE_ES_CORE_APP_RUNTIME_ERROR);
        -:  172:
        2:  173:}/* end CFE_SB_TaskMain */
        -:  174:
        -:  175:
        -:  176:
        -:  177:/******************************************************************************
        -:  178:**  Function:  CFE_SB_AppInit()
        -:  179:**
        -:  180:**  Purpose:
        -:  181:**    Initialization routine for SB application. This routine is executed when
        -:  182:**    the SB application is started by Executive Services.
        -:  183:**
        -:  184:**  Arguments:
        -:  185:**    none
        -:  186:**
        -:  187:**  Return:
        -:  188:**    CFE_SUCCESS if no errors, otherwise this function returns the error code
        -:  189:**    that was received from the function that detected the error.
        -:  190:**    
        -:  191:*/
       13:  192:int32 CFE_SB_AppInit(void){
        -:  193:
       13:  194:    uint32 CfgFileEventsToFilter = 0;    
       13:  195:    uint32 *TmpPtr = NULL;
       13:  196:    int32  Status = CFE_SUCCESS;
        -:  197:    
       13:  198:    Status = CFE_ES_RegisterApp();
        -:  199:
       13:  200:    if(Status != CFE_SUCCESS){
        1:  201:      CFE_ES_WriteToSysLog("SB:Call to CFE_ES_RegisterApp Failed:RC=0x%08X\n",Status);
        1:  202:      return Status;
        -:  203:    }/* end if */
        -:  204:
        -:  205:    /* Get the assigned Application ID for the SB Task */
       12:  206:    CFE_ES_GetAppID(&CFE_SB.AppId);
        -:  207:
        -:  208:    /* Process the platform cfg file events to be filtered */
        -:  209:    if(CFE_SB_FILTERED_EVENT1 != 0){
       12:  210:      CFE_SB.EventFilters[CfgFileEventsToFilter].EventID = CFE_SB_FILTERED_EVENT1;
       12:  211:      CFE_SB.EventFilters[CfgFileEventsToFilter].Mask    = CFE_SB_FILTER_MASK1;      
       12:  212:      CfgFileEventsToFilter++;
        -:  213:    }/* end if */           
        -:  214:
        -:  215:    if(CFE_SB_FILTERED_EVENT2 != 0){
       12:  216:      CFE_SB.EventFilters[CfgFileEventsToFilter].EventID = CFE_SB_FILTERED_EVENT2;
       12:  217:      CFE_SB.EventFilters[CfgFileEventsToFilter].Mask    = CFE_SB_FILTER_MASK2;      
       12:  218:      CfgFileEventsToFilter++;
        -:  219:    }/* end if */      
        -:  220:
        -:  221:    if(CFE_SB_FILTERED_EVENT3 != 0){
       12:  222:      CFE_SB.EventFilters[CfgFileEventsToFilter].EventID = CFE_SB_FILTERED_EVENT3;
       12:  223:      CFE_SB.EventFilters[CfgFileEventsToFilter].Mask    = CFE_SB_FILTER_MASK3;      
       12:  224:      CfgFileEventsToFilter++;
        -:  225:    }/* end if */      
        -:  226:
        -:  227:    if(CFE_SB_FILTERED_EVENT4 != 0){
       12:  228:      CFE_SB.EventFilters[CfgFileEventsToFilter].EventID = CFE_SB_FILTERED_EVENT4;
       12:  229:      CFE_SB.EventFilters[CfgFileEventsToFilter].Mask    = CFE_SB_FILTER_MASK4;      
       12:  230:      CfgFileEventsToFilter++;
        -:  231:    }/* end if */      
        -:  232:
        -:  233:    if(CFE_SB_FILTERED_EVENT5 != 0){
        -:  234:      CFE_SB.EventFilters[CfgFileEventsToFilter].EventID = CFE_SB_FILTERED_EVENT5;
        -:  235:      CFE_SB.EventFilters[CfgFileEventsToFilter].Mask    = CFE_SB_FILTER_MASK5;      
        -:  236:      CfgFileEventsToFilter++;
        -:  237:    }/* end if */      
        -:  238:
        -:  239:    if(CFE_SB_FILTERED_EVENT6 != 0){
        -:  240:      CFE_SB.EventFilters[CfgFileEventsToFilter].EventID = CFE_SB_FILTERED_EVENT6;
        -:  241:      CFE_SB.EventFilters[CfgFileEventsToFilter].Mask    = CFE_SB_FILTER_MASK6;      
        -:  242:      CfgFileEventsToFilter++;
        -:  243:    }/* end if */      
        -:  244:
        -:  245:    if(CFE_SB_FILTERED_EVENT7 != 0){
        -:  246:      CFE_SB.EventFilters[CfgFileEventsToFilter].EventID = CFE_SB_FILTERED_EVENT7;
        -:  247:      CFE_SB.EventFilters[CfgFileEventsToFilter].Mask    = CFE_SB_FILTER_MASK7;      
        -:  248:      CfgFileEventsToFilter++;
        -:  249:    }/* end if */      
        -:  250:
        -:  251:    if(CFE_SB_FILTERED_EVENT8 != 0){
        -:  252:      CFE_SB.EventFilters[CfgFileEventsToFilter].EventID = CFE_SB_FILTERED_EVENT8;
        -:  253:      CFE_SB.EventFilters[CfgFileEventsToFilter].Mask    = CFE_SB_FILTER_MASK8;      
        -:  254:      CfgFileEventsToFilter++;
        -:  255:    }/* end if */
        -:  256:    
        -:  257:    /* Be sure the number of events to register for filtering   
        -:  258:    ** does not exceed CFE_EVS_MAX_EVENT_FILTERS */
       12:  259:    if(CFE_EVS_MAX_EVENT_FILTERS < CfgFileEventsToFilter){
    #####:  260:      CfgFileEventsToFilter = CFE_EVS_MAX_EVENT_FILTERS;
        -:  261:    }/* end if */
        -:  262:
        -:  263:
        -:  264:    /* Register event filter table... */
       12:  265:    Status = CFE_EVS_Register(CFE_SB.EventFilters,
        -:  266:                              CfgFileEventsToFilter,
        -:  267:                              CFE_EVS_BINARY_FILTER);
       12:  268:    if(Status != CFE_SUCCESS){
        1:  269:      CFE_ES_WriteToSysLog("SB:Call to CFE_EVS_Register Failed:RC=0x%08X\n",Status);
        1:  270:      return Status;
        -:  271:    }/* end if */
        -:  272:    
       11:  273:    CFE_ES_WriteToSysLog("SB:Registered %d events for filtering\n",CfgFileEventsToFilter);
        -:  274:
       11:  275:    CFE_SB_InitMsg(&CFE_SB.HKTlmMsg.Hdr.Pri,
        -:  276:                   CFE_SB_HK_TLM_MID,
        -:  277:                   sizeof(CFE_SB_HKMsg_t),
        -:  278:                   TRUE);
        -:  279:
       11:  280:    CFE_SB_InitMsg(&CFE_SB.PrevSubMsg.Hdr.Pri,
        -:  281:                   CFE_SB_ALLSUBS_TLM_MID,
        -:  282:                   sizeof(CFE_SB_PrevSubMsg_t),
        -:  283:                   TRUE);
        -:  284:
       11:  285:    CFE_SB_InitMsg(&CFE_SB.SubRprtMsg.Hdr.Pri,
        -:  286:                   CFE_SB_ONESUB_TLM_MID,
        -:  287:                   sizeof(CFE_SB_SubRprtMsg_t),
        -:  288:                   TRUE);    
        -:  289:
        -:  290:    /* Populate the fixed fields in the HK Tlm Msg */
       11:  291:    CFE_SB.HKTlmMsg.MemPoolHandle = CFE_SB.Mem.PoolHdl;
        -:  292:    
        -:  293:    /* Populate the fixed fields in the Stat Tlm Msg */
       11:  294:    CFE_SB.StatTlmMsg.MaxMsgIdsAllowed = CFE_SB_MAX_MSG_IDS;
       11:  295:    CFE_SB.StatTlmMsg.MaxPipesAllowed  = CFE_SB_MAX_PIPES;
       11:  296:    CFE_SB.StatTlmMsg.MaxMemAllowed    = CFE_SB_BUF_MEMORY_BYTES;
       11:  297:    CFE_SB.StatTlmMsg.MaxPipeDepthAllowed = CFE_SB_MAX_PIPE_DEPTH;
       11:  298:    CFE_SB.StatTlmMsg.MaxSubscriptionsAllowed =
        -:  299:                    ((CFE_SB_MAX_MSG_IDS)*(CFE_SB_MAX_DEST_PER_PKT));
        -:  300:    
       11:  301:    Status = CFE_SB_CreatePipe(&CFE_SB.CmdPipe,
        -:  302:                                CFE_SB_CMD_PIPE_DEPTH,
        -:  303:                                CFE_SB_CMD_PIPE_NAME);
       11:  304:    if(Status != CFE_SUCCESS){
        1:  305:      CFE_ES_WriteToSysLog("SB:Call to CFE_SB_CreatePipe Failed:RC=0x%08X\n",Status);
        1:  306:      return Status;
        -:  307:    }/* end if */                                
        -:  308:
       10:  309:    Status = CFE_SB_Subscribe(CFE_SB_CMD_MID,CFE_SB.CmdPipe);
        -:  310:
       10:  311:    if(Status != CFE_SUCCESS){
        1:  312:      CFE_ES_WriteToSysLog("SB:Subscribe to Cmds Failed:RC=0x%08X\n",Status);
        1:  313:      return Status;
        -:  314:    }/* end if */
        -:  315:        
        9:  316:    Status = CFE_SB_Subscribe(CFE_SB_SEND_HK_MID,CFE_SB.CmdPipe);
        -:  317:
        9:  318:    if(Status != CFE_SUCCESS){
        1:  319:      CFE_ES_WriteToSysLog("SB:Subscribe to HK Request Failed:RC=0x%08X\n",Status);
        1:  320:      return Status;
        -:  321:    }/* end if */
        -:  322:     
        -:  323:    /* Ensure a ground commanded reset does not get blocked if SB mem pool  */
        -:  324:    /* becomes fully configured (DCR6772) */
        8:  325:    Status = CFE_ES_GetPoolBuf((uint32 **)&TmpPtr, CFE_SB.Mem.PoolHdl,
        -:  326:                                        sizeof(CFE_ES_RestartCmd_t));    
        -:  327:
        8:  328:    if(Status < 0){
        1:  329:      CFE_ES_WriteToSysLog("SB:Init error, GetPool Failed:RC=0x%08X\n",Status);
        1:  330:      return Status;
        -:  331:    }/* end if */
        -:  332:
        -:  333:    /* Return mem block used on previous call,the actual memory is not needed.*/
        -:  334:    /* The SB mem pool is now configured with a block size for the reset cmd. */
        7:  335:    Status = CFE_ES_PutPoolBuf(CFE_SB.Mem.PoolHdl, (uint32 *)TmpPtr);
        -:  336:
        7:  337:    if(Status < 0){
        2:  338:      CFE_ES_WriteToSysLog("SB:Init error, PutPool Failed:RC=0x%08X\n",Status);
        2:  339:      return Status;
        -:  340:    }/* end if */    
        -:  341:    
        5:  342:    Status = CFE_EVS_SendEvent(CFE_SB_INIT_EID,
        -:  343:                              CFE_EVS_INFORMATION,
        -:  344:                              "cFE SB Initialized");
        5:  345:    if(Status != CFE_SUCCESS){
        1:  346:      CFE_ES_WriteToSysLog("SB:Error sending init event:RC=0x%08X\n",Status);
        1:  347:      return Status;
        -:  348:    }/* end if */
        -:  349:                      
        4:  350:    return CFE_SUCCESS;                      
        -:  351:
        -:  352:}/* end CFE_SB_AppInit */
        -:  353:
        -:  354:
        -:  355:
        -:  356:
        -:  357:/******************************************************************************
        -:  358:**  Function:  CFE_SB_ProcessCmdPipePkt()
        -:  359:**
        -:  360:**  Purpose:
        -:  361:**    Function to control actions when an SB command is received.
        -:  362:**
        -:  363:**  Arguments:
        -:  364:**    none
        -:  365:**
        -:  366:**  Return:
        -:  367:**    none
        -:  368:*/
       26:  369:void CFE_SB_ProcessCmdPipePkt(void){
        -:  370:
       26:  371:   switch(CFE_SB_GetMsgId(CFE_SB.CmdPipePktPtr)){
        -:  372:
        -:  373:      case CFE_SB_SEND_HK_MID:
        -:  374:         /* Note: Command counter not incremented for this command */
        1:  375:         CFE_SB_SendHKTlmPkt();
        1:  376:         break;
        -:  377:
        -:  378:      case CFE_SB_CMD_MID:
       24:  379:         switch (CFE_SB_GetCmdCode(CFE_SB.CmdPipePktPtr)) {
        -:  380:            case CFE_SB_NOOP_CC:
        1:  381:               CFE_EVS_SendEvent(CFE_SB_CMD0_RCVD_EID,CFE_EVS_INFORMATION,
        -:  382:                                 "No-op Cmd Rcvd. cFE Version %d.%d.%d.%d",
        -:  383:                                 CFE_MAJOR_VERSION,CFE_MINOR_VERSION,CFE_REVISION,CFE_MISSION_REV);
        1:  384:               CFE_SB.HKTlmMsg.CommandCnt++;
        1:  385:               break;
        -:  386:
        -:  387:            case CFE_SB_RESET_CTRS_CC:
        -:  388:               /* Note: Command counter not incremented for this command */
        1:  389:               CFE_EVS_SendEvent(CFE_SB_CMD1_RCVD_EID,CFE_EVS_DEBUG,
        -:  390:                                 "Reset Counters Cmd Rcvd");
        1:  391:               CFE_SB_ResetCounters();
        1:  392:               break;
        -:  393:
        -:  394:            case CFE_SB_SEND_SB_STATS_CC:
        1:  395:                CFE_SB_SendStats();
        1:  396:                break;
        -:  397:
        -:  398:            case CFE_SB_SEND_ROUTING_INFO_CC:
        3:  399:                CFE_SB_ProcessSendRtgInfoCmd();
        3:  400:                break;
        -:  401:
        -:  402:            case CFE_SB_ENABLE_ROUTE_CC:
        5:  403:                CFE_SB_EnableRoute(CFE_SB.CmdPipePktPtr);
        5:  404:                break;
        -:  405:
        -:  406:            case CFE_SB_DISABLE_ROUTE_CC:
        5:  407:                CFE_SB_DisableRoute(CFE_SB.CmdPipePktPtr);
        5:  408:                break;
        -:  409:
        -:  410:            case CFE_SB_SEND_PIPE_INFO_CC:
        2:  411:                CFE_SB_ProcessSendPipeInfoCmd();
        2:  412:                break;
        -:  413:
        -:  414:            case CFE_SB_SEND_MAP_INFO_CC:
        2:  415:                CFE_SB_ProcessSendMapInfoCmd();
        2:  416:                break;
        -:  417:
        -:  418:            case CFE_SB_SEND_PREV_SUBS_CC:
        1:  419:                CFE_SB_SendPrevSubs();
        1:  420:                break;
        -:  421:
        -:  422:            case CFE_SB_ENABLE_SUB_REPORTING_CC:
        1:  423:                CFE_SB_SetSubscriptionReporting(CFE_SB_ENABLE);
        1:  424:                break;
        -:  425:
        -:  426:            case CFE_SB_DISABLE_SUB_REPORTING_CC:
        1:  427:                CFE_SB_SetSubscriptionReporting(CFE_SB_DISABLE);
        1:  428:                break;
        -:  429:
        -:  430:            default:
        1:  431:               CFE_EVS_SendEvent(CFE_SB_BAD_CMD_CODE_EID,CFE_EVS_ERROR,
        -:  432:                    "Invalid Cmd, Unexpected Command Code %d",
        -:  433:                     CFE_SB_GetCmdCode(CFE_SB.CmdPipePktPtr));
        1:  434:                     CFE_SB.HKTlmMsg.CmdErrCnt++;
        -:  435:               break;
        -:  436:         } /* end switch on cmd code */
       24:  437:         break;
        -:  438:
        -:  439:      default:
        1:  440:         CFE_EVS_SendEvent(CFE_SB_BAD_MSGID_EID,CFE_EVS_ERROR,
        -:  441:                 "Invalid Cmd, Unexpected Msg Id: 0x%04x",
        -:  442:                  CFE_SB_GetMsgId(CFE_SB.CmdPipePktPtr));
        1:  443:                  CFE_SB.HKTlmMsg.CmdErrCnt++;
        -:  444:         break;
        -:  445:
        -:  446:   } /* end switch on MsgId */
        -:  447:
       26:  448:} /* end CFE_SB_ProcessCmdPipePkt */
        -:  449:
        -:  450:
        -:  451:
        -:  452:/******************************************************************************
        -:  453:**  Function:  CFE_SB_SendHKTlmPkt()
        -:  454:**
        -:  455:**  Purpose:
        -:  456:**    Function to send the SB housekeeping packet.
        -:  457:**
        -:  458:**  Arguments:
        -:  459:**    none
        -:  460:**
        -:  461:**  Notes:
        -:  462:**    Command counter not incremented for this command
        -:  463:**
        -:  464:**  Return:
        -:  465:**    none
        -:  466:*/
        1:  467:void CFE_SB_SendHKTlmPkt(void){
        -:  468:    
        1:  469:    CFE_SB.HKTlmMsg.MemInUse        = CFE_SB.StatTlmMsg.MemInUse;    
        1:  470:    CFE_SB.HKTlmMsg.UnmarkedMem     = CFE_SB_BUF_MEMORY_BYTES - CFE_SB.StatTlmMsg.PeakMemInUse;
        -:  471:    
        1:  472:    CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &CFE_SB.HKTlmMsg);
        1:  473:    CFE_SB_SendMsg((CFE_SB_Msg_t *)&CFE_SB.HKTlmMsg);
        -:  474:
        1:  475:}/* end CFE_SB_SendHKTlmPkt */
        -:  476:
        -:  477:
        -:  478:/******************************************************************************
        -:  479:**  Function:  CFE_SB_ResetCounters()
        -:  480:**
        -:  481:**  Purpose:
        -:  482:**    Function to reset the SB housekeeping counters.
        -:  483:**
        -:  484:**  Arguments:
        -:  485:**    none
        -:  486:**
        -:  487:**  Notes:
        -:  488:**    Command counter not incremented for this command
        -:  489:**
        -:  490:**  Return:
        -:  491:**    none
        -:  492:*/
        1:  493:void CFE_SB_ResetCounters(void){
        -:  494:
        1:  495:   CFE_SB.HKTlmMsg.CommandCnt          = 0;
        1:  496:   CFE_SB.HKTlmMsg.CmdErrCnt           = 0;
        1:  497:   CFE_SB.HKTlmMsg.NoSubscribersCnt    = 0;
        1:  498:   CFE_SB.HKTlmMsg.DupSubscriptionsCnt = 0;
        1:  499:   CFE_SB.HKTlmMsg.MsgSendErrCnt       = 0;
        1:  500:   CFE_SB.HKTlmMsg.MsgReceiveErrCnt    = 0;
        1:  501:   CFE_SB.HKTlmMsg.InternalErrCnt      = 0;
        1:  502:   CFE_SB.HKTlmMsg.CreatePipeErrCnt    = 0;
        1:  503:   CFE_SB.HKTlmMsg.SubscribeErrCnt     = 0;
        1:  504:   CFE_SB.HKTlmMsg.PipeOverflowErrCnt  = 0;
        1:  505:   CFE_SB.HKTlmMsg.MsgLimErrCnt        = 0;
        -:  506:
        1:  507:}/* end CFE_SB_ResetCounters */
        -:  508:
        -:  509:
        -:  510:/******************************************************************************
        -:  511:**  Function:  CFE_SB_EnableRoute()
        -:  512:**
        -:  513:**  Purpose:
        -:  514:**    SB internal function to enable a specific route. A route is defined as a
        -:  515:**    MsgId/PipeId combination.
        -:  516:**
        -:  517:**  Arguments:
        -:  518:**    MsgPtr  : pointer to the message
        -:  519:**
        -:  520:**  Return:
        -:  521:**    None
        -:  522:*/
        5:  523:void CFE_SB_EnableRoute(CFE_SB_MsgPtr_t MsgPtr){
        -:  524:
        -:  525:    CFE_SB_MsgId_t          MsgId;
        -:  526:    CFE_SB_PipeId_t         PipeId;
        -:  527:    CFE_SB_DestinationD_t   *DestPtr;
        -:  528:    CFE_SB_EnRoutCmd_t      *CmdPtr;
        -:  529:
        5:  530:    CmdPtr = (CFE_SB_EnRoutCmd_t *)MsgPtr;
        -:  531:
        5:  532:    MsgId  = CmdPtr->MsgId;
        5:  533:    PipeId = CmdPtr->Pipe;
        -:  534:
        -:  535:    /* check cmd parameters */
        5:  536:    if((CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS)||
        -:  537:       (CFE_SB_ValidatePipeId(PipeId) != CFE_SUCCESS))
        -:  538:    {
        3:  539:        CFE_EVS_SendEvent(CFE_SB_ENBL_RTE3_EID,CFE_EVS_ERROR,
        -:  540:                      "Enbl Route Cmd:Invalid Param.Msg 0x%x,Pipe %d",MsgId,PipeId);
        3:  541:        CFE_SB.HKTlmMsg.CmdErrCnt++;
        3:  542:        return;
        -:  543:    }/* end if */
        -:  544:
        2:  545:    DestPtr = CFE_SB_GetDestPtr(MsgId, PipeId);
        2:  546:    if(DestPtr == NULL){
        1:  547:        CFE_EVS_SendEvent(CFE_SB_ENBL_RTE1_EID,CFE_EVS_ERROR,
        -:  548:                "Enbl Route Cmd:Route does not exist.Msg 0x%x,Pipe %d",MsgId,PipeId);
        1:  549:        CFE_SB.HKTlmMsg.CmdErrCnt++;
        1:  550:        return;
        -:  551:    }/* end if */
        -:  552:
        1:  553:    DestPtr->Active = CFE_SB_ACTIVE;
        1:  554:    CFE_EVS_SendEvent(CFE_SB_ENBL_RTE2_EID,CFE_EVS_DEBUG,
        -:  555:                      "Enabling Route,Msg 0x%x,Pipe %d",MsgId,PipeId);
        -:  556:
        1:  557:    CFE_SB.HKTlmMsg.CommandCnt++;
        -:  558:
        -:  559:}/* end CFE_SB_EnableRoute */
        -:  560:
        -:  561:
        -:  562:
        -:  563:/******************************************************************************
        -:  564:**  Function:  CFE_SB_DisableRoute()
        -:  565:**
        -:  566:**  Purpose:
        -:  567:**    SB internal function to disable a specific route. A route is defined as a
        -:  568:**    MsgId/PipeId combination.
        -:  569:**
        -:  570:**  Arguments:
        -:  571:**    MsgPtr  : pointer to the message
        -:  572:**
        -:  573:**  Return:
        -:  574:**    None
        -:  575:*/
        5:  576:void CFE_SB_DisableRoute(CFE_SB_MsgPtr_t MsgPtr){
        -:  577:
        -:  578:    CFE_SB_MsgId_t          MsgId;
        -:  579:    CFE_SB_PipeId_t         PipeId;
        -:  580:    CFE_SB_DestinationD_t   *DestPtr;
        -:  581:    CFE_SB_EnRoutCmd_t      *CmdPtr;
        -:  582:
        5:  583:    CmdPtr = (CFE_SB_EnRoutCmd_t *)MsgPtr;
        -:  584:
        5:  585:    MsgId  = CmdPtr->MsgId;
        5:  586:    PipeId = CmdPtr->Pipe;
        -:  587:
        -:  588:    /* check cmd parameters */
        5:  589:    if((CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS)||
        -:  590:       (CFE_SB_ValidatePipeId(PipeId) != CFE_SUCCESS)){
        3:  591:        CFE_EVS_SendEvent(CFE_SB_DSBL_RTE3_EID,CFE_EVS_ERROR,
        -:  592:                   "Disable Route Cmd:Invalid Param.Msg 0x%x,Pipe %d",MsgId,PipeId);
        3:  593:        CFE_SB.HKTlmMsg.CmdErrCnt++;
        3:  594:        return;
        -:  595:    }/* end if */
        -:  596:
        2:  597:    DestPtr = CFE_SB_GetDestPtr(MsgId, PipeId);
        2:  598:    if(DestPtr == NULL){
        1:  599:        CFE_EVS_SendEvent(CFE_SB_DSBL_RTE1_EID,CFE_EVS_ERROR,
        -:  600:            "Disable Route Cmd:Route does not exist,Msg 0x%x,Pipe %d",MsgId,PipeId);
        1:  601:        CFE_SB.HKTlmMsg.CmdErrCnt++;
        1:  602:        return;
        -:  603:    }/* end if */
        -:  604:
        1:  605:    DestPtr->Active = CFE_SB_INACTIVE;
        -:  606:
        1:  607:    CFE_EVS_SendEvent(CFE_SB_DSBL_RTE2_EID,CFE_EVS_DEBUG,
        -:  608:                      "Route Disabled,Msg 0x%x,Pipe %d",MsgId,PipeId);
        1:  609:    CFE_SB.HKTlmMsg.CommandCnt++;
        -:  610:
        -:  611:}/* end CFE_SB_DisableRoute */
        -:  612:
        -:  613:
        -:  614:/******************************************************************************
        -:  615:**  Function:  CFE_SB_SendStats()
        -:  616:**
        -:  617:**  Purpose:
        -:  618:**    SB internal function to send a Software Bus statistics packet
        -:  619:**
        -:  620:**  Arguments:
        -:  621:**    None
        -:  622:**
        -:  623:**  Return:
        -:  624:**    None
        -:  625:*/
        1:  626:void CFE_SB_SendStats(void){
        -:  627:
        1:  628:    CFE_SB_SendMsg((CFE_SB_Msg_t *)&CFE_SB.StatTlmMsg);
        -:  629:
        1:  630:    CFE_EVS_SendEvent(CFE_SB_SND_STATS_EID,CFE_EVS_DEBUG,
        -:  631:                      "Software Bus Statistics packet sent");
        -:  632:
        1:  633:    CFE_SB.HKTlmMsg.CommandCnt++;
        -:  634:
        1:  635:}/* CFE_SB_SendStats */
        -:  636:
        -:  637:
        -:  638:/******************************************************************************
        -:  639:**  Function:  CFE_SB_ProcessSendRtgInfoCmd()
        -:  640:**
        -:  641:**  Purpose:
        -:  642:**    SB internal function to handle processing of 'Send Routing Info' Cmd
        -:  643:**
        -:  644:**  Arguments:
        -:  645:**    None
        -:  646:**
        -:  647:**  Return:
        -:  648:**    None
        -:  649:*/
        3:  650:void CFE_SB_ProcessSendRtgInfoCmd(void){
        -:  651:
        -:  652:    CFE_SB_WriteFileInfoCmd_t *ptr;
        -:  653:    int32 Stat;
        -:  654:
        3:  655:    ptr = (CFE_SB_WriteFileInfoCmd_t *)CFE_SB.CmdPipePktPtr;
        -:  656:
        3:  657:    if((ptr->Filename[0])=='\0'){
        1:  658:      Stat = CFE_SB_SendRtgInfo(CFE_SB_DEFAULT_ROUTING_FILENAME);
        -:  659:    }else{
        2:  660:      ptr->Filename[OS_MAX_PATH_LEN - 1] = '\0';
        2:  661:      Stat = CFE_SB_SendRtgInfo(ptr->Filename);
        -:  662:    }/* end if */
        -:  663:
        3:  664:    CFE_SB_IncrCmdCtr(Stat);
        -:  665:
        3:  666:}/* end CFE_SB_ProcessSendRtgInfoCmd */
        -:  667:
        -:  668:
        -:  669:/******************************************************************************
        -:  670:**  Function:  CFE_SB_ProcessSendPipeInfoCmd()
        -:  671:**
        -:  672:**  Purpose:
        -:  673:**    SB internal function to handle processing of 'Send Pipe Info' Cmd
        -:  674:**
        -:  675:**  Arguments:
        -:  676:**    None
        -:  677:**
        -:  678:**  Return:
        -:  679:**    None
        -:  680:*/
        2:  681:void CFE_SB_ProcessSendPipeInfoCmd(void){
        -:  682:
        -:  683:    CFE_SB_WriteFileInfoCmd_t *ptr;
        -:  684:    int32 Stat;
        -:  685:
        2:  686:    ptr = (CFE_SB_WriteFileInfoCmd_t *)CFE_SB.CmdPipePktPtr;
        -:  687:
        2:  688:    if((ptr->Filename[0])=='\0'){
        1:  689:      Stat = CFE_SB_SendPipeInfo(CFE_SB_DEFAULT_PIPE_FILENAME);
        -:  690:    }else{
        1:  691:      ptr->Filename[OS_MAX_PATH_LEN - 1] = '\0';
        1:  692:      Stat = CFE_SB_SendPipeInfo(ptr->Filename);
        -:  693:    }/* end if */
        -:  694:
        2:  695:    CFE_SB_IncrCmdCtr(Stat);
        -:  696:
        2:  697:}/* end CFE_SB_ProcessSendPipeInfoCmd */
        -:  698:
        -:  699:
        -:  700:/******************************************************************************
        -:  701:**  Function:  CFE_SB_ProcessSendMapInfoCmd()
        -:  702:**
        -:  703:**  Purpose:
        -:  704:**    SB internal function to handle processing of 'Send Map Info' Cmd
        -:  705:**
        -:  706:**  Arguments:
        -:  707:**    None
        -:  708:**
        -:  709:**  Return:
        -:  710:**    None
        -:  711:*/
        2:  712:void CFE_SB_ProcessSendMapInfoCmd(void){
        -:  713:
        -:  714:    CFE_SB_WriteFileInfoCmd_t *ptr;
        -:  715:    int32 Stat;
        -:  716:
        2:  717:    ptr = (CFE_SB_WriteFileInfoCmd_t *)CFE_SB.CmdPipePktPtr;
        -:  718:
        2:  719:    if((ptr->Filename[0])=='\0'){
        1:  720:      Stat = CFE_SB_SendMapInfo(CFE_SB_DEFAULT_MAP_FILENAME);
        -:  721:    }else{
        1:  722:      ptr->Filename[OS_MAX_PATH_LEN - 1] = '\0';
        1:  723:      Stat = CFE_SB_SendMapInfo((char *)ptr->Filename);
        -:  724:    }/* end if */
        -:  725:
        2:  726:    CFE_SB_IncrCmdCtr(Stat);
        -:  727:
        2:  728:}/* end CFE_SB_ProcessSendMapInfoCmd */
        -:  729:
        -:  730:
        -:  731:/******************************************************************************
        -:  732:**  Function:  CFE_SB_SendRoutingInfo()
        -:  733:**
        -:  734:**  Purpose:
        -:  735:**    SB internal function to write the routing information to a file
        -:  736:**
        -:  737:**  Arguments:
        -:  738:**    Pointer to a filename
        -:  739:**
        -:  740:**  Return:
        -:  741:**    CFE_SB_FILE_IO_ERR for file I/O errors or CFE_SUCCESS
        -:  742:*/
        5:  743:int32 CFE_SB_SendRtgInfo(char *Filename){
        -:  744:
        5:  745:    CFE_SB_MsgId_t              RtgTblIdx = 0;
        -:  746:    CFE_SB_MsgId_t              i;
        5:  747:    int32                       fd = 0;
        -:  748:    int32                       WriteStat;
        5:  749:    uint32                      FileSize = 0;
        5:  750:    uint32                      EntryCount = 0;
        -:  751:    CFE_SB_RoutingFileEntry_t   Entry;
        -:  752:    CFE_FS_Header_t             FileHdr;
        -:  753:    CFE_SB_PipeD_t              *pd; 
        -:  754:    CFE_SB_DestinationD_t       *DestPtr;
        -:  755:
        5:  756:    fd = OS_creat(Filename, OS_WRITE_ONLY);
        5:  757:    if(fd < OS_FS_SUCCESS){
        1:  758:        OS_close(fd);
        1:  759:        CFE_EVS_SendEvent(CFE_SB_SND_RTG_ERR1_EID,CFE_EVS_ERROR,
        -:  760:                      "Error creating file %s, stat=0x%x",
        -:  761:                      Filename,fd);
        1:  762:        return CFE_SB_FILE_IO_ERR;
        -:  763:    }/* end if */
        -:  764:
        -:  765:    /* clear out the cfe file header fields, then populate description and subtype */
        4:  766:    CFE_PSP_MemSet(&FileHdr, 0, sizeof(CFE_FS_Header_t));
        4:  767:    strcpy(&FileHdr.Description[0], "SB Routing Information");
        4:  768:    FileHdr.SubType = CFE_FS_SB_ROUTEDATA_SUBTYPE;
        -:  769:
        4:  770:    WriteStat = CFE_FS_WriteHeader(fd, &FileHdr);
        4:  771:    if(WriteStat != sizeof(CFE_FS_Header_t)){
        1:  772:        CFE_SB_FileWriteByteCntErr(Filename,sizeof(CFE_FS_Header_t),WriteStat);
        1:  773:        OS_close(fd);
        1:  774:        return CFE_SB_FILE_IO_ERR;
        -:  775:    }/* end if */
        -:  776:
        3:  777:    FileSize = WriteStat;
        -:  778:
        -:  779:    /* loop through the entire MsgMap */
    22540:  780:    for(i=0;i<CFE_SB_HIGHEST_VALID_MSGID;i++){
        -:  781:
    22538:  782:        RtgTblIdx = CFE_SB.MsgMap[i];
    22538:  783:        if(RtgTblIdx == CFE_SB_AVAILABLE){
    22534:  784:          continue;
        -:  785:        }/* end if */
        -:  786:
        4:  787:        DestPtr = CFE_SB.RoutingTbl[RtgTblIdx].ListHeadPtr;
        -:  788:
       11:  789:        while(DestPtr != NULL){
        -:  790:
        4:  791:            pd = CFE_SB_GetPipePtr(DestPtr -> PipeId);
        4:  792:            if(pd == NULL)continue;
        -:  793:
        4:  794:            Entry.MsgId     = CFE_SB.RoutingTbl[RtgTblIdx].MsgId;
        4:  795:            Entry.PipeId    = DestPtr -> PipeId;
        4:  796:            Entry.State     = DestPtr -> Active;
        4:  797:            Entry.MsgCnt    = DestPtr -> DestCnt;               
        -:  798:            
        4:  799:            CFE_ES_GetAppName(&Entry.AppName[0], pd->AppId, OS_MAX_API_NAME);
        4:  800:            Entry.AppName[OS_MAX_API_NAME-1] = '\0';
        4:  801:            strncpy(&Entry.PipeName[0],CFE_SB_GetPipeName(Entry.PipeId),OS_MAX_API_NAME);
        4:  802:            Entry.PipeName[OS_MAX_API_NAME-1] = '\0';
        -:  803:
        4:  804:            WriteStat = OS_write (fd, &Entry, sizeof(CFE_SB_RoutingFileEntry_t));
        4:  805:            if(WriteStat != sizeof(CFE_SB_RoutingFileEntry_t)){
        1:  806:                CFE_SB_FileWriteByteCntErr(Filename,sizeof(CFE_SB_RoutingFileEntry_t),WriteStat);
        1:  807:                OS_close(fd);
        1:  808:                return CFE_SB_FILE_IO_ERR;
        -:  809:            }/* end if */
        -:  810:
        3:  811:            FileSize += WriteStat;
        3:  812:            EntryCount ++;
        -:  813:            
        3:  814:            DestPtr = DestPtr->Next;
        -:  815:
        -:  816:        }/* end while */
        -:  817:
        -:  818:    }/* end for */
        -:  819:
        2:  820:    OS_close(fd);
        -:  821:
        2:  822:    CFE_EVS_SendEvent(CFE_SB_SND_RTG_EID,CFE_EVS_DEBUG,
        -:  823:                      "%s written:Size=%d,Entries=%d",
        -:  824:                      Filename,FileSize,EntryCount);
        -:  825:
        2:  826:    return CFE_SUCCESS;
        -:  827:
        -:  828:}/* end CFE_SB_SendRtgInfo */
        -:  829:
        -:  830:
        -:  831:/******************************************************************************
        -:  832:**  Function:  CFE_SB_SendPipeInfo()
        -:  833:**
        -:  834:**  Purpose:
        -:  835:**    SB internal function to write the Pipe table to a file
        -:  836:**
        -:  837:**  Arguments:
        -:  838:**    Pointer to a filename
        -:  839:**
        -:  840:**  Return:
        -:  841:**    CFE_SB_FILE_IO_ERR for file I/O errors or CFE_SUCCESS
        -:  842:*/
        5:  843:int32 CFE_SB_SendPipeInfo(char *Filename){
        -:  844:
        -:  845:    uint16 i;
        5:  846:    int32  fd = 0;
        -:  847:    int32  WriteStat;
        5:  848:    uint32 FileSize = 0;
        5:  849:    uint32 EntryCount = 0;
        -:  850:    CFE_FS_Header_t FileHdr;
        -:  851:
        5:  852:    fd = OS_creat(Filename, OS_WRITE_ONLY);
        -:  853:
        5:  854:    if(fd < OS_FS_SUCCESS){
        1:  855:        OS_close(fd);
        1:  856:        CFE_EVS_SendEvent(CFE_SB_SND_RTG_ERR1_EID,CFE_EVS_ERROR,
        -:  857:                          "Error creating file %s, stat=0x%x",
        -:  858:                           Filename,fd);
        1:  859:        return CFE_SB_FILE_IO_ERR;
        -:  860:    }/* end if */
        -:  861:
        -:  862:    /* clear out the cfe file header fields, then populate description and subtype */
        4:  863:    CFE_PSP_MemSet(&FileHdr, 0, sizeof(CFE_FS_Header_t));
        4:  864:    strcpy(&FileHdr.Description[0], "SB Pipe Information");
        4:  865:    FileHdr.SubType = CFE_FS_SB_PIPEDATA_SUBTYPE;
        -:  866:    
        4:  867:    WriteStat = CFE_FS_WriteHeader(fd, &FileHdr);
        4:  868:    if(WriteStat != sizeof(CFE_FS_Header_t)){
        1:  869:        CFE_SB_FileWriteByteCntErr(Filename,sizeof(CFE_FS_Header_t),WriteStat);
        1:  870:        OS_close(fd);
        1:  871:        return CFE_SB_FILE_IO_ERR;
        -:  872:    }/* end if */
        -:  873:
        3:  874:    FileSize = WriteStat;
        -:  875:
        -:  876:    /* loop through the pipe table */
      132:  877:    for(i=0;i<CFE_SB_MAX_PIPES;i++){
        -:  878:
      130:  879:        if(CFE_SB.PipeTbl[i].InUse==CFE_SB_IN_USE){
        -:  880:
        5:  881:            WriteStat = OS_write (fd, &(CFE_SB.PipeTbl[i]), sizeof(CFE_SB_PipeD_t));
        5:  882:            if(WriteStat != sizeof(CFE_SB_PipeD_t)){
        1:  883:                CFE_SB_FileWriteByteCntErr(Filename,sizeof(CFE_SB_PipeD_t),WriteStat);
        1:  884:                OS_close(fd);
        1:  885:                return CFE_SB_FILE_IO_ERR;
        -:  886:            }/* end if */
        -:  887:
        4:  888:            FileSize += WriteStat;
        4:  889:            EntryCount ++;
        -:  890:
        -:  891:        }/* end if */
        -:  892:
        -:  893:    }/* end for */
        -:  894:
        2:  895:    OS_close(fd);
        -:  896:
        2:  897:    CFE_EVS_SendEvent(CFE_SB_SND_RTG_EID,CFE_EVS_DEBUG,
        -:  898:                      "%s written:Size=%d,Entries=%d",
        -:  899:                       Filename,FileSize,EntryCount);
        -:  900:
        2:  901:    return CFE_SUCCESS;
        -:  902:
        -:  903:}/* end CFE_SB_SendPipeInfo */
        -:  904:
        -:  905:
        -:  906:/******************************************************************************
        -:  907:**  Function:  CFE_SB_SendMapInfo()
        -:  908:**
        -:  909:**  Purpose:
        -:  910:**    SB internal function to write the Message Map to a file
        -:  911:**
        -:  912:**  Arguments:
        -:  913:**    Pointer to a filename
        -:  914:**
        -:  915:**  Return:
        -:  916:**    CFE_SB_FILE_IO_ERR for file I/O errors or CFE_SUCCESS
        -:  917:*/
        5:  918:int32 CFE_SB_SendMapInfo(char *Filename){
        -:  919:
        -:  920:    uint16 i;
        5:  921:    int32  fd = 0;
        -:  922:    int32  WriteStat;
        5:  923:    uint32 FileSize = 0;
        5:  924:    uint32 EntryCount = 0;
        -:  925:    CFE_SB_MsgMapFileEntry_t Entry;
        -:  926:    CFE_FS_Header_t FileHdr;
        -:  927:
        5:  928:    fd = OS_creat(Filename, OS_WRITE_ONLY);
        -:  929:
        5:  930:    if (fd < OS_FS_SUCCESS){
        1:  931:        OS_close(fd);
        1:  932:        CFE_EVS_SendEvent(CFE_SB_SND_RTG_ERR1_EID,CFE_EVS_ERROR,
        -:  933:                          "Error creating file %s, stat=0x%x",
        -:  934:                           Filename,fd);
        1:  935:        return CFE_SB_FILE_IO_ERR;
        -:  936:    }/* end if */
        -:  937:
        -:  938:    /* clear out the cfe file header fields, then populate description and subtype */
        4:  939:    CFE_PSP_MemSet(&FileHdr, 0, sizeof(CFE_FS_Header_t));
        4:  940:    strcpy(&FileHdr.Description[0], "SB Message Map Information");
        4:  941:    FileHdr.SubType = CFE_FS_SB_MAPDATA_SUBTYPE;
        -:  942:
        4:  943:    WriteStat = CFE_FS_WriteHeader(fd, &FileHdr);
        4:  944:    if(WriteStat != sizeof(CFE_FS_Header_t)){
        1:  945:        CFE_SB_FileWriteByteCntErr(Filename,sizeof(CFE_FS_Header_t),WriteStat);
        1:  946:        OS_close(fd);
        1:  947:        return CFE_SB_FILE_IO_ERR;
        -:  948:    }/* end if */
        -:  949:
        3:  950:    FileSize = WriteStat;
        -:  951:
        -:  952:    /* loop through the entire MsgMap */
    18443:  953:    for(i=0;i<CFE_SB_HIGHEST_VALID_MSGID;i++){
        -:  954:
    18441:  955:        if(CFE_SB.MsgMap[i] != CFE_SB_AVAILABLE){
        -:  956:
        8:  957:            Entry.MsgId = i;
        8:  958:            Entry.Index = CFE_SB.MsgMap[i];
        -:  959:
        8:  960:            WriteStat = OS_write (fd, &Entry, sizeof(CFE_SB_MsgMapFileEntry_t));
        8:  961:            if(WriteStat != sizeof(CFE_SB_MsgMapFileEntry_t)){
        1:  962:                CFE_SB_FileWriteByteCntErr(Filename,sizeof(CFE_SB_MsgMapFileEntry_t),WriteStat);
        1:  963:                OS_close(fd);
        1:  964:                return CFE_SB_FILE_IO_ERR;
        -:  965:            }/* end if */
        -:  966:
        7:  967:            FileSize += WriteStat;
        7:  968:            EntryCount ++;
        -:  969:
        -:  970:        }/* end for */
        -:  971:    }/* end for */
        -:  972:
        2:  973:    OS_close(fd);
        -:  974:
        2:  975:    CFE_EVS_SendEvent(CFE_SB_SND_RTG_EID,CFE_EVS_DEBUG,
        -:  976:                      "%s written:Size=%d,Entries=%d",
        -:  977:                      Filename,FileSize,EntryCount);
        -:  978:
        2:  979:    return CFE_SUCCESS;
        -:  980:
        -:  981:}/* end CFE_SB_SendMapInfo */
        -:  982:
        -:  983:
        -:  984:
        -:  985:/******************************************************************************
        -:  986:**  Function:  CFE_SB_SendPrevSubs()
        -:  987:**
        -:  988:**  Purpose:
        -:  989:**    SB function to build and send an SB packet containing a complete list of
        -:  990:**    current subscriptions.Intended to be used primarily for the Software Bus
        -:  991:**    Networking Application (SBN).
        -:  992:**
        -:  993:**  Arguments:
        -:  994:**    None
        -:  995:**
        -:  996:**  Return:
        -:  997:**    None
        -:  998:*/
        2:  999:void CFE_SB_SendPrevSubs(void){
        -: 1000:
        -: 1001:  uint32 i;
        2: 1002:  uint32 EntryNum = 0;
        2: 1003:  uint32 SegNum = 1;
        -: 1004:  int32  Stat;
        2: 1005:  CFE_SB_DestinationD_t *DestPtr = NULL;
        -: 1006:
        -: 1007:  /* Take semaphore to ensure data does not change during this function */
        2: 1008:  CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1009:
        -: 1010:  /* seek msgids that are in use */
      514: 1011:  for(i=0;i<CFE_SB_MAX_MSG_IDS;i++){
        -: 1012:
      512: 1013:      if(CFE_SB.RoutingTbl[i].MsgId == CFE_SB_INVALID_MSG_ID)
      464: 1014:        continue;
        -: 1015:
       48: 1016:        DestPtr = CFE_SB.RoutingTbl[i].ListHeadPtr;
        -: 1017:
       97: 1018:        while(DestPtr != NULL){
        -: 1019:
       49: 1020:            if(DestPtr->Scope == CFE_SB_GLOBAL){
        -: 1021:            
        -: 1022:                /* ...add entry into pkt */
       48: 1023:                CFE_SB.PrevSubMsg.Entry[EntryNum].MsgId = CFE_SB.RoutingTbl[i].MsgId;
       48: 1024:                CFE_SB.PrevSubMsg.Entry[EntryNum].Qos.Priority = 0;
       48: 1025:                CFE_SB.PrevSubMsg.Entry[EntryNum].Qos.Reliability = 0;
       48: 1026:                EntryNum++;
        -: 1027:        
        -: 1028:                /* send pkt if full */
       48: 1029:                if(EntryNum >= CFE_SB_SUB_ENTRIES_PER_PKT){
        2: 1030:                  CFE_SB.PrevSubMsg.PktSegment = SegNum;
        2: 1031:                  CFE_SB.PrevSubMsg.Entries = EntryNum;
        2: 1032:                  CFE_SB_UnlockSharedData(__func__,__LINE__);
        2: 1033:                  Stat = CFE_SB_SendMsg((CFE_SB_Msg_t *)&CFE_SB.PrevSubMsg);
        2: 1034:                  CFE_SB_LockSharedData(__func__,__LINE__);
        2: 1035:                  CFE_EVS_SendEvent(CFE_SB_FULL_SUB_PKT_EID,CFE_EVS_DEBUG,
        -: 1036:                      "Full Sub Pkt %d Sent,Entries=%d,Stat=0x%x\n",SegNum,EntryNum,Stat);
        2: 1037:                  EntryNum = 0;
        2: 1038:                  SegNum++;
        -: 1039:                }/* end if */
        -: 1040:        
        -: 1041:                /* break while loop through destinations, onto next CFE_SB.RoutingTbl index */
        -: 1042:                /* This is done because we want only one network subscription per msgid */
        -: 1043:                /* Later when Qos is used, we may want to take just the highest priority */
        -: 1044:                /* subscription if there are more than one */
       48: 1045:                break;
        -: 1046:                
        -: 1047:            }/* end if */
        -: 1048:            
        -: 1049:            /* Check next destination (if another exists) for global scope */
        1: 1050:            DestPtr = DestPtr -> Next;
        -: 1051:        
        -: 1052:        }/* end while */
        -: 1053:  
        -: 1054:  }/* end for */ 
        -: 1055:
        -: 1056:  /* if pkt has any number of entries, send it as a partial pkt */
        2: 1057:  if(EntryNum > 0){
        2: 1058:    CFE_SB.PrevSubMsg.PktSegment = SegNum;
        2: 1059:    CFE_SB.PrevSubMsg.Entries = EntryNum;
        2: 1060:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        2: 1061:    Stat = CFE_SB_SendMsg((CFE_SB_Msg_t *)&CFE_SB.PrevSubMsg);
        2: 1062:    CFE_SB_LockSharedData(__func__,__LINE__);
        2: 1063:    CFE_EVS_SendEvent(CFE_SB_PART_SUB_PKT_EID,CFE_EVS_DEBUG,
        -: 1064:        "Partial Sub Pkt %d Sent,Entries=%d,Stat=0x%x",SegNum,EntryNum,Stat);
        -: 1065:  }/* end if */
        -: 1066:
        2: 1067:  CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1068:  return;
        -: 1069:
        -: 1070:}/* end CFE_SB_SendPrevSubs */
        -: 1071:
        -: 1072:
        -: 1073:/******************************************************************************
        -: 1074:**  Function:  CFE_SB_FindGlobalMsgIdCnt()
        -: 1075:**
        -: 1076:**  Purpose:
        -: 1077:**    SB internal function to get a count of the global message ids in use.
        -: 1078:**
        -: 1079:**  Notes:
        -: 1080:**    Subscriptions made with CFE_SB_SubscribeLocal would not be counted.
        -: 1081:**    Subscription made with a subscribe API other than CFE_SB_SubscribeLocal are
        -: 1082:**    considerd to be global subscriptions. MsgIds with both global and local
        -: 1083:**    subscriptions would be counted.
        -: 1084:**
        -: 1085:**  Arguments:
        -: 1086:**
        -: 1087:**  Return:
        -: 1088:**    None
        -: 1089:*/
        1: 1090:uint32 CFE_SB_FindGlobalMsgIdCnt(void){
        -: 1091:
        -: 1092:    uint32 i;
        1: 1093:    uint32 cnt = 0;
        1: 1094:    CFE_SB_DestinationD_t *DestPtr = NULL;
        -: 1095:    
      257: 1096:    for(i=0;i<CFE_SB_MAX_MSG_IDS;i++){
        -: 1097:
      256: 1098:        if(CFE_SB.RoutingTbl[i].MsgId == CFE_SB_INVALID_MSG_ID)
      253: 1099:            continue;
        -: 1100:
        3: 1101:        DestPtr = CFE_SB.RoutingTbl[i].ListHeadPtr;
        -: 1102:    
        7: 1103:        while(DestPtr != NULL){
        -: 1104:    
        4: 1105:            if(DestPtr->Scope == CFE_SB_GLOBAL){
        -: 1106:
        3: 1107:                cnt++;
        3: 1108:                break;
        -: 1109:
        -: 1110:            }/* end if */
        -: 1111:            
        -: 1112:            /* Check next destination (if another exists) for global scope */
        1: 1113:            DestPtr = DestPtr -> Next;
        -: 1114:            
        -: 1115:        }/* end while */
        -: 1116:
        -: 1117:    }/* end for */
        -: 1118:
        1: 1119:  return cnt;
        -: 1120:
        -: 1121:}/* end CFE_SB_FindGlobalMsgIdCnt */
        -: 1122:
        -: 1123:
        -: 1124:
        -: 1125:
        -: 1126:/******************************************************************************
        -: 1127:**  Function:  CFE_SB_IncrCmdCtr()
        -: 1128:**
        -: 1129:**  Purpose:
        -: 1130:**    SB internal function to increment the proper cmd counter based on the
        -: 1131:**    status input. This small utility was written to eliminate duplicate code.
        -: 1132:**
        -: 1133:**  Arguments:
        -: 1134:**    status - typically CFE_SUCCESS or an SB error code
        -: 1135:**
        -: 1136:**  Return:
        -: 1137:**    None
        -: 1138:*/
        7: 1139:void CFE_SB_IncrCmdCtr(int32 status){
        -: 1140:
        7: 1141:    if(status==CFE_SUCCESS){
        6: 1142:      CFE_SB.HKTlmMsg.CommandCnt++;
        -: 1143:    }else{
        1: 1144:      CFE_SB.HKTlmMsg.CmdErrCnt++;
        -: 1145:    }/* end if */
        -: 1146:
        7: 1147:}/* end CFE_SB_IncrCmdCtr */
        -: 1148:
        -: 1149:
        -: 1150:
        -: 1151:/******************************************************************************
        -: 1152:**  Function:  CFE_SB_FileWriteByteCntErr()
        -: 1153:**
        -: 1154:**  Purpose:
        -: 1155:**    SB internal function to report a file write error
        -: 1156:**
        -: 1157:**  Arguments:
        -: 1158:**
        -: 1159:**
        -: 1160:**  Return:
        -: 1161:**    None
        -: 1162:*/
        6: 1163:void CFE_SB_FileWriteByteCntErr(char *Filename,uint32 Requested,uint32 Actual){
        -: 1164:
        6: 1165:    CFE_EVS_SendEvent(CFE_SB_FILEWRITE_ERR_EID,CFE_EVS_ERROR,
        -: 1166:                      "File write,byte cnt err,file %s,request=%d,actual=%d",
        -: 1167:                       Filename,Requested,Actual);
        -: 1168:
        6: 1169:}/* end CFE_SB_FileWriteByteCntErr() */
        -: 1170:
        -: 1171:
        -: 1172:/******************************************************************************
        -: 1173:**  Function:  CFE_SB_SetSubscriptionReporting()
        -: 1174:**
        -: 1175:**  Purpose:
        -: 1176:**    SB internal function to enable and disable subscription reporting.
        -: 1177:**
        -: 1178:**  Arguments:
        -: 1179:**
        -: 1180:**
        -: 1181:**  Return:
        -: 1182:**    None
        -: 1183:*/
        6: 1184:void CFE_SB_SetSubscriptionReporting(uint32 state){
        -: 1185:
        6: 1186:    CFE_SB.SubscriptionReporting = state;
        -: 1187:
        6: 1188:}/* end CFE_SB_SetSubscriptionReporting */
        -: 1189:
        -: 1190:
        -: 1191:
        -: 1192:
        -: 1193:
