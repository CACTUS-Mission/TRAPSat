        -:    0:Source:/home/wmoleski/CFS/mission_2014/cfe/fsw/cfe-core/src/sb/cfe_sb_api.c
        -:    0:Graph:cfe_sb_api.gcno
        -:    0:Data:cfe_sb_api.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/******************************************************************************
        -:    2:** File: cfe_sb_api.c
        -:    3:**
        -:    4:**      Copyright (c) 2004-2012, United States government as represented by the
        -:    5:**      administrator of the National Aeronautics Space Administration.
        -:    6:**      All rights reserved. This software(cFE) was created at NASA's Goddard
        -:    7:**      Space Flight Center pursuant to government contracts.
        -:    8:**
        -:    9:**      This is governed by the NASA Open Source Agreement and may be used,
        -:   10:**      distributed and modified only pursuant to the terms of that agreement.
        -:   11:**
        -:   12:**
        -:   13:**
        -:   14:** Purpose:
        -:   15:**      This file contains the source code for the SB API's.
        -:   16:**
        -:   17:** Author:   R.McGraw/SSI
        -:   18:**
        -:   19:** $Log: cfe_sb_api.c.gcov  $
        -:   19:** Revision 1.5 2015/06/24 12:19:13EDT wmoleski 
        -:   19:** Checking in the unit-test results for cFE 6.4.2.0
        -:   20:** Revision 1.40 2014/08/22 16:41:25GMT-05:00 lwalling 
        -:   21:** Change signed loop counters to unsigned
        -:   22:** Revision 1.39 2014/06/17 13:42:34EDT rmcgraw 
        -:   23:** DCR18686:1 Initialized all AppId and CallerID's with 0xFFFFFFFF
        -:   24:** Revision 1.38 2014/05/05 14:47:16EDT rmcgraw
        -:   25:** DCR19498:1 Fixed buffers in use count, was going negative for zero copy transfers
        -:   26:** Revision 1.37 2014/05/05 13:53:09EDT rmcgraw
        -:   27:** DCR19578:1 - Add UnlockSharedData for errors in ZeroCopyReleaseDesc
        -:   28:** Revision 1.36 2014/04/24 10:57:07EDT rmcgraw
        -:   29:** DCR19487:1 - Remove size argument in CFE_SB_GetBufferFromCaller
        -:   30:** Revision 1.35 2012/07/09 15:00:18EDT rmcgraw
        -:   31:** DCR19413:1 Release buf mem for zero cpy send, no subscribers and error cases
        -:   32:** Revision 1.34 2012/01/13 12:15:11EST acudmore
        -:   33:** Changed license text to reflect open source
        -:   34:** Revision 1.33 2012/01/06 09:27:19EST rmcgraw
        -:   35:** DCR16100:1 Added perf markers for msg lim and pipe overflow errors
        -:   36:** Revision 1.32 2011/12/20 10:25:30GMT-05:00 rmcgraw
        -:   37:** DCR15187:1 Removed function CFE_SB_DecrMsgLimCnt and MsgLim Counter error event
        -:   38:** Revision 1.31 2011/12/09 12:22:56EST rmcgraw
        -:   39:** DCR15763:1 Added call to LockSharedData for case of invalid pipe id rcvd in RcvMsg API
        -:   40:** Revision 1.30 2011/09/09 14:25:33EDT aschoeni
        -:   41:** Added fix for ZeroCopy issues
        -:   42:** Revision 1.29 2011/04/29 10:04:48EDT rmcgraw
        -:   43:** Add check for NULL ptr in send loop
        -:   44:** Revision 1.28 2011/04/28 10:37:31EDT rmcgraw
        -:   45:** Fixed compiler error
        -:   46:** Revision 1.27 2011/04/28 10:10:15EDT rmcgraw
        -:   47:** DCR14592:1 Fix for the SB Send semaphore problem
        -:   48:** Revision 1.26 2010/11/04 16:41:53EDT aschoeni
        -:   49:** Added optional sender information storage
        -:   50:** Revision 1.25 2010/11/04 14:27:15EDT aschoeni
        -:   51:** Optimized rcv function
        -:   52:** Revision 1.24 2010/11/03 15:07:01EDT jmdagost
        -:   53:** Added cfe.h include file.
        -:   54:** Revision 1.23 2009/07/29 19:23:26EDT aschoeni
        -:   55:** Updated for ZeroCopyHandle_t and GetPoolBufInfo
        -:   56:** Revision 1.22 2009/07/24 18:27:10EDT aschoeni
        -:   57:** Added Zero Copy Mode
        -:   58:** Revision 1.21 2009/07/20 14:10:54EDT aschoeni
        -:   59:** Made GetAppTskName reentrant
        -:   60:** Revision 1.20 2009/07/17 19:43:01EDT aschoeni
        -:   61:** Added PassMsg API to sb to support sequence count preservation
        -:   62:** Revision 1.19 2009/06/26 17:02:07EDT aschoeni
        -:   63:** Updated SB to use __func__ instead of __FILE__ for lock and unlock errors
        -:   64:** Revision 1.18 2009/06/10 09:17:57EDT acudmore
        -:   65:** Updated OS_Mem* and OS_BSP* to CFE_PSP_*
        -:   66:** Revision 1.17 2009/05/08 11:27:08EDT rmcgraw
        -:   67:** DCR7631:1 Removed index checks in Subscribe and Unsubscribe - dead code and cannot be tested
        -:   68:** Revision 1.16 2009/04/29 10:04:33EDT rmcgraw
        -:   69:** DCR5801:11 Changed subscription return value when buf allocation fails
        -:   70:** Revision 1.15 2009/03/30 10:45:01EDT rmcgraw
        -:   71:** DCR5801:2 Fixed infinite loop when deleting a pipe with subscriptions
        -:   72:** Revision 1.14 2009/02/26 17:57:39EST rmcgraw
        -:   73:** DCR6805:1 Corrected note under SendMsg API prolog regarding seq count
        -:   74:** Revision 1.13 2009/02/10 16:53:23EST rmcgraw
        -:   75:** DCR1700:1 Decrement pipes-in-use counter in DeletePipe API
        -:   76:** Revision 1.12 2009/02/10 12:29:07EST rmcgraw
        -:   77:** DCR6956:1 In Create Pipe API, set user's pipe id to invalid for error cases
        -:   78:** Revision 1.11 2009/02/10 11:25:56EST rmcgraw
        -:   79:** DCR1699:1 Removed pipe owner in five events
        -:   80:** Revision 1.10 2009/02/06 15:35:08EST rmcgraw
        -:   81:** DCR5801:3 Moved Total Msg Size test before the lock in the send api
        -:   82:** Revision 1.9 2009/02/06 11:29:04EST rmcgraw
        -:   83:** DCR5801:2 General Cleanup
        -:   84:** Revision 1.8 2009/02/03 16:33:29EST rmcgraw
        -:   85:** DCR5801:2 Fixed DestPtr errors in Send API
        -:   86:** Revision 1.7 2009/02/03 11:06:58EST rmcgraw
        -:   87:** DCR5801:2 Changed destination desciptors from array based to linked list
        -:   88:** Revision 1.6 2009/01/30 12:27:07EST rmcgraw
        -:   89:** DCR5801:5 Removed call to GetPipePtr in send API inside loop
        -:   90:** Revision 1.5 2009/01/30 11:50:07EST rmcgraw
        -:   91:** DCR5801:8 Set users ptr to null only when readqueue fails in rcv API
        -:   92:** Revision 1.4 2009/01/30 11:45:06EST rmcgraw
        -:   93:** DCR5801:9 Removed unused calls to GetAppID in send and rcv APIs
        -:   94:** Revision 1.3 2009/01/30 11:07:03EST rmcgraw
        -:   95:** DCR5801:3 Moved the semaphore lock in the send and rcv API's
        -:   96:** Revision 1.2 2009/01/30 10:34:57EST rmcgraw
        -:   97:** DCR5801:1 Began tracking subsribers with 'destinations' counter.
        -:   98:** Revision 1.1 2008/04/17 08:05:30EDT ruperera
        -:   99:** Initial revision
        -:  100:** Member added to cfe project on tlserver3
        -:  101:** Revision 1.74 2007/09/19 14:38:48EDT rjmcgraw
        -:  102:** DCR4421 Removed use count err events and reworded buf allocation error event
        -:  103:** Revision 1.73 2007/09/19 12:01:46EDT rjmcgraw
        -:  104:** Return code in unsubscribe changed from no subscribers to cfe success
        -:  105:** Revision 1.72 2007/09/13 09:34:09EDT rjmcgraw
        -:  106:** DCR4861:2 Added check in SendMsg to prevent recursive event problem
        -:  107:** Revision 1.71 2007/08/17 15:59:51EDT rjmcgraw
        -:  108:** Changes to free semaphore before calling SendEventWithAppId
        -:  109:** Revision 1.70 2007/07/12 16:58:22EDT rjmcgraw
        -:  110:** DCR4680:1 Removed SB event log related items
        -:  111:** Revision 1.69 2007/07/06 13:34:17EDT rjmcgraw
        -:  112:** DCR469:1 Added GetLastSender code
        -:  113:** Revision 1.68 2007/04/24 11:07:18EDT rjmcgraw
        -:  114:** Added PipeId to PipeDepthStats
        -:  115:** Revision 1.67 2007/04/24 09:34:04EDT rjmcgraw
        -:  116:** DCR3294 - Added pipe depth stats to several SB api's
        -:  117:** Revision 1.66 2007/03/28 14:17:37EST rjmcgraw
        -:  118:** Sending TskId instead of AppId in call to LogSBEvent - DCR2654
        -:  119:** Revision 1.65 2007/03/27 13:42:28EST rjmcgraw
        -:  120:** Added step to increment new duplicate subscription counter
        -:  121:**
        -:  122:******************************************************************************/
        -:  123:
        -:  124:/*
        -:  125:** Include Files
        -:  126:*/
        -:  127:#include "common_types.h"
        -:  128:#include "cfe.h"
        -:  129:#include "cfe_sb_events.h"
        -:  130:#include "cfe_sb_priv.h"
        -:  131:#include "cfe_sb.h"
        -:  132:#include "osapi.h"
        -:  133:#include "cfe_es.h"
        -:  134:#include "cfe_psp.h"
        -:  135:#include "cfe_error.h"
        -:  136:#include <string.h>
        -:  137:
        -:  138:/*
        -:  139:** External Globals
        -:  140:*/
        -:  141:extern cfe_sb_t CFE_SB;
        -:  142:
        -:  143:
        -:  144:/******************************************************************************
        -:  145:** Name:    CFE_SB_CreatePipe
        -:  146:**
        -:  147:** Purpose: API to create a pipe for receiving messages
        -:  148:**
        -:  149:** Assumptions, External Events, and Notes:
        -:  150:**
        -:  151:**          Note: Zero is a valid PipeId
        -:  152:**
        -:  153:** Date Written:
        -:  154:**          04/25/2005
        -:  155:**
        -:  156:** Inputs:
        -:  157:**          PipeIdPtr - Ptr to users empty PipeId variable, to be filled by
        -:  158:**                      this function.
        -:  159:**          Depth     - The depth of the pipe, synonymous to the max number
        -:  160:**                      of messages the pipe can hold at any time.
        -:  161:**          PipeName  - The name of the pipe displayed in event messages
        -:  162:**
        -:  163:** Outputs:
        -:  164:**          PipeId    - The handle of the pipe to be used when receiving
        -:  165:**                      messages.
        -:  166:**
        -:  167:** Return Values:
        -:  168:**          Status
        -:  169:**
        -:  170:******************************************************************************/
        -:  171:int32  CFE_SB_CreatePipe(CFE_SB_PipeId_t *PipeIdPtr, uint16  Depth, char *PipeName)
      181:  172:{
      181:  173:    uint32          AppId = 0xFFFFFFFF;
      181:  174:    uint32          TskId = 0;
      181:  175:    uint32          SysQueueId = 0;
        -:  176:    int32           Status;
        -:  177:    CFE_SB_PipeId_t PipeTblIdx;
      181:  178:    char            AppName[OS_MAX_API_NAME] = {'\0'};
        -:  179:    char            FullName[(OS_MAX_API_NAME * 2)];
        -:  180:
        -:  181:    /* take semaphore to prevent a task switch during this call */
      181:  182:    CFE_SB_LockSharedData(__func__,__LINE__);
        -:  183:
      181:  184:    TskId = OS_TaskGetId();
        -:  185:
        -:  186:    /* set user's pipe id value to 'invalid' for error cases below */
      181:  187:    if(PipeIdPtr != NULL){
      180:  188:        *PipeIdPtr = CFE_SB_INVALID_PIPE;
        -:  189:    }/* end if */
        -:  190:
        -:  191:    /* check input parameters */
      181:  192:    if((PipeIdPtr == NULL)||(Depth > CFE_SB_MAX_PIPE_DEPTH)||(Depth == 0)){
        4:  193:        CFE_SB.HKTlmMsg.CreatePipeErrCnt++;
        4:  194:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        4:  195:        CFE_EVS_SendEventWithAppID(CFE_SB_CR_PIPE_BAD_ARG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  196:          "CreatePipeErr:Bad Input Arg:app=%s,ptr=0x%x,depth=%d,maxdepth=%d",
        -:  197:                CFE_SB_GetAppTskName(TskId,FullName),(uint32)PipeIdPtr,Depth,CFE_SB_MAX_PIPE_DEPTH);
        4:  198:        return CFE_SB_BAD_ARGUMENT;
        -:  199:    }/*end if*/
        -:  200:
        -:  201:    /* get first available entry in pipe table */
      177:  202:    PipeTblIdx = CFE_SB_GetAvailPipeIdx();
        -:  203:
        -:  204:    /* if pipe table is full, send event and return error */
      177:  205:    if(PipeTblIdx == CFE_SB_INVALID_PIPE){
        1:  206:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  207:        CFE_EVS_SendEventWithAppID(CFE_SB_MAX_PIPES_MET_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  208:          "CreatePipeErr:Max Pipes(%d)In Use.app %s",
        -:  209:          CFE_SB_MAX_PIPES,CFE_SB_GetAppTskName(TskId,FullName));
        1:  210:        return CFE_SB_MAX_PIPES_MET;
        -:  211:    }/* end if */
        -:  212:
        -:  213:    /* create the queue */
      176:  214:    Status = OS_QueueCreate(&SysQueueId,PipeName,Depth,sizeof(CFE_SB_BufferD_t *),0);
      176:  215:    if (Status != OS_SUCCESS) {
        4:  216:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        4:  217:        CFE_EVS_SendEventWithAppID(CFE_SB_CR_PIPE_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  218:                "CreatePipeErr:OS_QueueCreate returned %d,app %s",
        -:  219:                Status,CFE_SB_GetAppTskName(TskId,FullName));
        4:  220:        return CFE_SB_PIPE_CR_ERR;
        -:  221:    }/* end if */
        -:  222:
        -:  223:    /* get callers AppId */
      172:  224:    CFE_ES_GetAppID(&AppId);
        -:  225:
        -:  226:    /* get callers name */
      172:  227:    CFE_ES_GetAppName(AppName, AppId, OS_MAX_API_NAME);
        -:  228:
        -:  229:    /* Hardcode a NULL terminator, in case rcvd name was too long */
      172:  230:    AppName[OS_MAX_API_NAME-1]= '\0';
        -:  231:
        -:  232:    /* fill in the pipe table fields */
      172:  233:    CFE_SB.PipeTbl[PipeTblIdx].InUse       = CFE_SB_IN_USE;
      172:  234:    CFE_SB.PipeTbl[PipeTblIdx].SysQueueId  = SysQueueId;
      172:  235:    CFE_SB.PipeTbl[PipeTblIdx].PipeId      = PipeTblIdx;
      172:  236:    CFE_SB.PipeTbl[PipeTblIdx].QueueDepth  = Depth;
      172:  237:    CFE_SB.PipeTbl[PipeTblIdx].AppId       = AppId;
      172:  238:    CFE_SB.PipeTbl[PipeTblIdx].SendErrors  = 0;
      172:  239:    CFE_SB.PipeTbl[PipeTblIdx].CurrentBuff = NULL;
      172:  240:    CFE_SB.PipeTbl[PipeTblIdx].ToTrashBuff = NULL;
      172:  241:    strcpy(&CFE_SB.PipeTbl[PipeTblIdx].AppName[0],&AppName[0]);
      172:  242:    strncpy(&CFE_SB.PipeTbl[PipeTblIdx].PipeName[0],PipeName,OS_MAX_API_NAME);
      172:  243:    CFE_SB.PipeTbl[PipeTblIdx].PipeName[OS_MAX_API_NAME-1]='\0';
        -:  244:
        -:  245:    /* Increment the Pipes in use ctr and if it's > the high water mark,*/
        -:  246:    /* adjust the high water mark */
      172:  247:    CFE_SB.StatTlmMsg.PipesInUse++;
      172:  248:    if(CFE_SB.StatTlmMsg.PipesInUse > CFE_SB.StatTlmMsg.PeakPipesInUse){
      169:  249:       CFE_SB.StatTlmMsg.PeakPipesInUse = CFE_SB.StatTlmMsg.PipesInUse;
        -:  250:    }/* end if */
        -:  251:
        -:  252:    /* Reset the pipe depth parameters in the statistics pkt */
      172:  253:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].PipeId = PipeTblIdx;
      172:  254:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].Depth = Depth;
      172:  255:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].InUse = 0;
      172:  256:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].PeakInUse = 0;
        -:  257:
        -:  258:    /* give the pipe handle to the caller */
      172:  259:    *PipeIdPtr = PipeTblIdx;
        -:  260:
      172:  261:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -:  262:
        -:  263:    /* send debug event */
      172:  264:    CFE_EVS_SendEventWithAppID(CFE_SB_PIPE_ADDED_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  265:          "Pipe Created:name %s,id %d,app %s",
        -:  266:          CFE_SB_GetPipeName(CFE_SB.PipeTbl[PipeTblIdx].PipeId),
        -:  267:          CFE_SB.PipeTbl[PipeTblIdx].PipeId,
        -:  268:          CFE_SB_GetAppTskName(TskId,FullName));
        -:  269:
      172:  270:    return CFE_SUCCESS;
        -:  271:
        -:  272:}/* end CFE_SB_CreatePipe */
        -:  273:
        -:  274:
        -:  275:/******************************************************************************
        -:  276:**  Function:  CFE_SB_DeletePipe()
        -:  277:**
        -:  278:**  Purpose:
        -:  279:**    Will unsubscribe to all routes associated with the given pipe id, then remove
        -:  280:**    pipe from the pipe table.
        -:  281:**
        -:  282:**  Arguments:
        -:  283:**    PipeId - The ID of the pipe to delete.
        -:  284:**
        -:  285:**  Return:
        -:  286:**    CFE_SUCCESS or cFE Error Code
        -:  287:*/
        -:  288:int32 CFE_SB_DeletePipe(CFE_SB_PipeId_t PipeId)
      169:  289:{
      169:  290:    uint32  CallerId = 0xFFFFFFFF;
      169:  291:    int32   Status = 0;
        -:  292:
        -:  293:    /* get the callers Application Id */
      169:  294:    CFE_ES_GetAppID(&CallerId);
        -:  295:
      169:  296:    Status = CFE_SB_DeletePipeFull(PipeId,CallerId);
        -:  297:
      169:  298:    return Status;
        -:  299:
        -:  300:}/* end CFE_SB_DeletePipe */
        -:  301:
        -:  302:
        -:  303:
        -:  304:/******************************************************************************
        -:  305:**  Function:  CFE_SB_DeletePipeWithAppId()
        -:  306:**
        -:  307:**  Purpose:
        -:  308:**
        -:  309:**
        -:  310:**  Arguments:
        -:  311:**    PipeId - The ID of the pipe to delete.
        -:  312:**
        -:  313:**  Return:
        -:  314:**    CFE_SUCCESS or cFE Error Code
        -:  315:*/
        -:  316:int32 CFE_SB_DeletePipeWithAppId(CFE_SB_PipeId_t PipeId, uint32 AppId)
        2:  317:{
        2:  318:    int32   Status = 0;
        -:  319:
        2:  320:    Status = CFE_SB_DeletePipeFull(PipeId,AppId);
        -:  321:
        2:  322:    return Status;
        -:  323:
        -:  324:}/* end CFE_SB_DeletePipeWithAppId */
        -:  325:
        -:  326:
        -:  327:
        -:  328:/******************************************************************************
        -:  329:**  Function:  CFE_SB_DeletePipeFull()
        -:  330:**
        -:  331:**  Purpose:
        -:  332:**    Will unsubscribe to all routes associated with the given pipe id, then remove
        -:  333:**    pipe from the pipe table.
        -:  334:**
        -:  335:**  NOTE:This function cannot be called directly, it would not be semaphore protected
        -:  336:**
        -:  337:**  Arguments:
        -:  338:**    PipeId - The ID of the pipe to delete.
        -:  339:**
        -:  340:**  Return:
        -:  341:**    CFE_SUCCESS or cFE Error Code
        -:  342:*/
        -:  343:int32 CFE_SB_DeletePipeFull(CFE_SB_PipeId_t PipeId,uint32 AppId)
      171:  344:{
        -:  345:    uint8         PipeTblIdx;
        -:  346:    int32         RtnFromVal,Stat;
        -:  347:    uint32        Owner,i;
      171:  348:    uint32        TskId = 0;
        -:  349:    CFE_SB_Msg_t  *PipeMsgPtr;
      171:  350:    CFE_SB_DestinationD_t *DestPtr = NULL;
        -:  351:    char          FullName[(OS_MAX_API_NAME * 2)];
        -:  352:
        -:  353:    /* take semaphore to prevent a task switch during this call */
      171:  354:    CFE_SB_LockSharedData(__func__,__LINE__);
        -:  355:
        -:  356:    /* get TaskId of caller for events */
      171:  357:    TskId = OS_TaskGetId();
        -:  358:
        -:  359:    /* check input parameter */
      171:  360:    PipeTblIdx = CFE_SB_GetPipeIdx(PipeId);
      171:  361:    RtnFromVal = CFE_SB_ValidatePipeId(PipeId);
      171:  362:    if((RtnFromVal != CFE_SUCCESS)||(PipeTblIdx == CFE_SB_INVALID_PIPE))
        -:  363:    {
        1:  364:        CFE_SB.HKTlmMsg.CreatePipeErrCnt++;
        1:  365:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  366:        CFE_EVS_SendEventWithAppID(CFE_SB_DEL_PIPE_ERR1_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  367:          "Pipe Delete Error:Bad Argument,PipedId %d,Requestor %s,Idx %d,Stat %d",
        -:  368:          PipeId,CFE_SB_GetAppTskName(TskId,FullName),PipeTblIdx,RtnFromVal);
        1:  369:        return CFE_SB_BAD_ARGUMENT;
        -:  370:    }/* end if */
        -:  371:
      170:  372:    Owner = CFE_SB.PipeTbl[PipeTblIdx].AppId;
        -:  373:
        -:  374:    /* check that the given AppId is the owner of the pipe */
      170:  375:    if(AppId != Owner){
        1:  376:        CFE_SB.HKTlmMsg.CreatePipeErrCnt++;
        1:  377:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  378:        CFE_EVS_SendEventWithAppID(CFE_SB_DEL_PIPE_ERR2_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  379:          "Pipe Delete Error:Caller(%s) is not the owner of pipe %d",
        -:  380:          CFE_SB_GetAppTskName(TskId,FullName),PipeId);
        1:  381:        return CFE_SB_BAD_ARGUMENT;
        -:  382:    }/* end if */
        -:  383:
        -:  384:    /* check destination list of every in-use MsgId, for the given pipeid. */
        -:  385:    /* when found, remove the pipe ID from the destination list via 'unsubscribe' */
    43433:  386:    for(i=0;i<CFE_SB_MAX_MSG_IDS;i++){
    43264:  387:        if(CFE_SB.RoutingTbl[i].MsgId != CFE_SB_INVALID_MSG_ID){
        -:  388:
      931:  389:            DestPtr = CFE_SB.RoutingTbl[i].ListHeadPtr;
        -:  390:
     2927:  391:            while(DestPtr != NULL){
        -:  392:
     1065:  393:                if(DestPtr -> PipeId == PipeId){
        -:  394:                    /* release the semaphore, unsubscribe will need to take it */
      401:  395:                    CFE_SB_UnlockSharedData(__func__,__LINE__);
      401:  396:                    CFE_SB_UnsubscribeWithAppId(CFE_SB.RoutingTbl[i].MsgId,
        -:  397:                                       PipeId,AppId);
      401:  398:                    CFE_SB_LockSharedData(__func__,__LINE__);
        -:  399:                }/* end if */
        -:  400:
     1065:  401:                DestPtr = DestPtr -> Next;
        -:  402:
        -:  403:            }/* end while */
        -:  404:
        -:  405:        }/* end if */
        -:  406:    }/* end for */
        -:  407:
      169:  408:    if (CFE_SB.PipeTbl[PipeTblIdx].ToTrashBuff != NULL) {
        -:  409:
        -:  410:        /* Decrement the Buffer Use Count and Free buffer if cnt=0) */
        1:  411:        CFE_SB_DecrBufUseCnt(CFE_SB.PipeTbl[PipeTblIdx].ToTrashBuff);
        1:  412:        CFE_SB.PipeTbl[PipeTblIdx].ToTrashBuff = NULL;
        -:  413:
        -:  414:    }/* end if */
        -:  415:
        -:  416:
        -:  417:    /* remove any messages that might be on the pipe */
        -:  418:    /* this step will free the memory used to store the message */
        -:  419:    do{
      173:  420:      CFE_SB_UnlockSharedData(__func__,__LINE__);
      173:  421:      Stat = CFE_SB_RcvMsg(&PipeMsgPtr,PipeId,CFE_SB_POLL);
      173:  422:      CFE_SB_LockSharedData(__func__,__LINE__);
      173:  423:    }while(Stat == CFE_SUCCESS);
        -:  424:
        -:  425:    /* Delete the underlying OS queue */
      169:  426:    OS_QueueDelete(CFE_SB.PipeTbl[PipeTblIdx].SysQueueId);
        -:  427:
        -:  428:    /* remove the pipe from the pipe table */
      169:  429:    CFE_SB.PipeTbl[PipeTblIdx].InUse         = CFE_SB_NOT_IN_USE;
      169:  430:    CFE_SB.PipeTbl[PipeTblIdx].SysQueueId    = CFE_SB_UNUSED_QUEUE;
      169:  431:    CFE_SB.PipeTbl[PipeTblIdx].PipeId        = CFE_SB_INVALID_PIPE;
      169:  432:    CFE_SB.PipeTbl[PipeTblIdx].CurrentBuff   = NULL;
      169:  433:    CFE_PSP_MemSet(&CFE_SB.PipeTbl[PipeTblIdx].PipeName[0],0,OS_MAX_API_NAME);
        -:  434:
        -:  435:    /* zero out the pipe depth stats */
      169:  436:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].PipeId = 0;
      169:  437:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].Depth = 0;
      169:  438:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].InUse = 0;
      169:  439:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].PeakInUse = 0;
        -:  440:
      169:  441:    CFE_SB.StatTlmMsg.PipesInUse--;
        -:  442:
      169:  443:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -:  444:
      169:  445:    CFE_EVS_SendEventWithAppID(CFE_SB_PIPE_DELETED_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  446:          "Pipe Deleted:id %d,owner %s",PipeId, CFE_SB_GetAppTskName(Owner,FullName));
        -:  447:
      169:  448:    return CFE_SUCCESS;
        -:  449:
        -:  450:}/* end CFE_SB_DeletePipeFull */
        -:  451:
        -:  452:
        -:  453:/******************************************************************************
        -:  454:** Name:    CFE_SB_SubscribeEx
        -:  455:**
        -:  456:** Purpose: API to globally subscribe to a message when QOS and MsgLim defaults
        -:  457:**          are insufficient.
        -:  458:**
        -:  459:** Assumptions, External Events, and Notes:
        -:  460:**
        -:  461:**          Note: Qos default: priority is low, reliability is low
        -:  462:**          Note: MsgLim default: 4, see Input Arguments below for more detail
        -:  463:**          Note: Qos parameter is currently unused by the fsw. It is recommended
        -:  464:**                to give a value of zero for Quality.Priority and Quality.Reliability
        -:  465:**
        -:  466:** Date Written:
        -:  467:**          04/25/2005
        -:  468:**
        -:  469:** Input Arguments:
        -:  470:**          MsgId   - The requesting message
        -:  471:**          PipeId  - The Pipe ID to send the message to
        -:  472:**          Quality - Quality of Service (Qos) - priority and reliability,
        -:  473:**                    see note above for recommended settings
        -:  474:**          MsgLim  - Max number of messages, with this MsgId, allowed on the
        -:  475:**                    pipe at any time.
        -:  476:**
        -:  477:** Output Arguments:
        -:  478:**          None
        -:  479:**
        -:  480:** Return Values:
        -:  481:**          Status
        -:  482:**
        -:  483:******************************************************************************/
        -:  484:int32  CFE_SB_SubscribeEx(CFE_SB_MsgId_t   MsgId,
        -:  485:                          CFE_SB_PipeId_t  PipeId,
        -:  486:                          CFE_SB_Qos_t     Quality,
        -:  487:                          uint16           MsgLim)
        3:  488:{
        3:  489:    return CFE_SB_SubscribeFull(MsgId,PipeId,Quality,MsgLim,(uint8)CFE_SB_GLOBAL);
        -:  490:
        -:  491:}/* end CFE_SB_SubscribeEx */
        -:  492:
        -:  493:
        -:  494:
        -:  495:
        -:  496:/******************************************************************************
        -:  497:** Name:    CFE_SB_SubscribeLocal
        -:  498:**
        -:  499:** Purpose: CFE Internal API to locally subscribe to a message when QOS and
        -:  500:**          MsgLim defaults are insufficient.
        -:  501:**
        -:  502:** Assumptions, External Events, and Notes:
        -:  503:**
        -:  504:**          Note: Qos default: priority is low, reliability is low
        -:  505:**                MsgLim default: 4 - meaning at most 4 messages of given
        -:  506:**                                    MsgId allowed on the given PipeId.
        -:  507:**
        -:  508:** Date Written:
        -:  509:**          04/25/2005
        -:  510:**
        -:  511:** Input Arguments:
        -:  512:**          MsgId   - The requesting message
        -:  513:**          PipeId  - The Pipe ID to send the message to
        -:  514:**          MsgLim  - Max number of messages, with this MsgId, allowed on the
        -:  515:**                    pipe at any time.
        -:  516:**
        -:  517:** Output Arguments:
        -:  518:**          None
        -:  519:**
        -:  520:** Return Values:
        -:  521:**          Status
        -:  522:**
        -:  523:******************************************************************************/
        -:  524:int32 CFE_SB_SubscribeLocal(CFE_SB_MsgId_t   MsgId,
        -:  525:                            CFE_SB_PipeId_t  PipeId,
        -:  526:                            uint16           MsgLim)
        3:  527:{
        3:  528:    return CFE_SB_SubscribeFull(MsgId,PipeId,CFE_SB_Default_Qos,MsgLim,
        -:  529:                                (uint8)CFE_SB_LOCAL);
        -:  530:
        -:  531:}/* end CFE_SB_SubscribeLocal */
        -:  532:
        -:  533:
        -:  534:
        -:  535:
        -:  536:/******************************************************************************
        -:  537:** Name:    CFE_SB_Subscribe
        -:  538:**
        -:  539:** Purpose: API to locally subscribe to a message when QOS and MsgLim defaults
        -:  540:**          are sufficient.
        -:  541:**
        -:  542:** Assumptions, External Events, and Notes:
        -:  543:**
        -:  544:**          Note: Qos default: priority is low, reliability is low
        -:  545:**                MsgLim default: 4 - meaning at most 4 messages of given
        -:  546:**                                    MsgId allowed on the given PipeId.
        -:  547:**
        -:  548:** Date Written:
        -:  549:**          04/25/2005
        -:  550:**
        -:  551:** Input Arguments:
        -:  552:**          MsgId   - The requesting message
        -:  553:**          PipeId  - The Pipe ID to send the message to
        -:  554:**
        -:  555:** Output Arguments:
        -:  556:**          None
        -:  557:**
        -:  558:** Return Values:
        -:  559:**          Status
        -:  560:**
        -:  561:******************************************************************************/
        -:  562:int32 CFE_SB_Subscribe(CFE_SB_MsgId_t   MsgId,
        -:  563:                       CFE_SB_PipeId_t  PipeId)
      409:  564:{
      409:  565:    return CFE_SB_SubscribeFull(MsgId,PipeId,CFE_SB_Default_Qos,
        -:  566:                               (uint16)CFE_SB_DEFAULT_MSG_LIMIT,
        -:  567:                               (uint8)CFE_SB_GLOBAL);
        -:  568:
        -:  569:}/* end CFE_SB_Subscribe */
        -:  570:
        -:  571:
        -:  572:/******************************************************************************
        -:  573:** Name:    CFE_SB_SubscribeFull
        -:  574:**
        -:  575:** Purpose: CFE Internal API used to subscribe to a message. Contains an input
        -:  576:**          parameter for all possible subscription choices. This function is
        -:  577:**          called by CFE_SB_SubscribeEx, CFE_SB_Subscribe and
        -:  578:**          CFE_SB_SubscribeLocal.
        -:  579:**
        -:  580:** Assumptions, External Events, and Notes:
        -:  581:**          None
        -:  582:**
        -:  583:** Date Written:
        -:  584:**          04/25/2005
        -:  585:**
        -:  586:** Input Arguments:
        -:  587:**          MsgId   - The requesting message
        -:  588:**          PipeId  - The Pipe ID to send the message to
        -:  589:**          Quality - Quality of Service (Qos) - priority and reliability
        -:  590:**          MsgLim  - Max number of messages, with this MsgId, allowed on the
        -:  591:**                    pipe at any time.
        -:  592:**          Scope   - Local subscription or broadcasted to peers
        -:  593:**
        -:  594:** Output Arguments:
        -:  595:**          None
        -:  596:**
        -:  597:** Return Values:
        -:  598:**          Status
        -:  599:**
        -:  600:******************************************************************************/
        -:  601:int32  CFE_SB_SubscribeFull(CFE_SB_MsgId_t   MsgId,
        -:  602:                            CFE_SB_PipeId_t  PipeId,
        -:  603:                            CFE_SB_Qos_t     Quality,
        -:  604:                            uint16           MsgLim,
        -:  605:                            uint8            Scope)
      415:  606:{
        -:  607:    uint16 Idx;
        -:  608:    int32  Stat;
      415:  609:    uint32 TskId = 0;
      415:  610:    uint32 AppId = 0xFFFFFFFF;
        -:  611:    uint8  PipeIdx;
      415:  612:    CFE_SB_DestinationD_t *DestBlkPtr = NULL;
        -:  613:    char   FullName[(OS_MAX_API_NAME * 2)];
        -:  614:
        -:  615:    /* take semaphore to prevent a task switch during this call */
      415:  616:    CFE_SB_LockSharedData(__func__,__LINE__);
        -:  617:
        -:  618:    /* get task id for events */
      415:  619:    TskId = OS_TaskGetId();
        -:  620:
        -:  621:    /* get the callers Application Id */
      415:  622:    CFE_ES_GetAppID(&AppId);
        -:  623:
        -:  624:    /* check that the pipe has been created */
      415:  625:    PipeIdx = CFE_SB_GetPipeIdx(PipeId);
      415:  626:    if(PipeIdx==CFE_SB_INVALID_PIPE){
        2:  627:      CFE_SB.HKTlmMsg.SubscribeErrCnt++;
        2:  628:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        2:  629:      CFE_EVS_SendEventWithAppID(CFE_SB_SUB_INV_PIPE_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  630:          "Subscribe Err:Invalid Pipe Id,Msg=0x%x,PipeId=%d,App %s",MsgId,PipeId,
        -:  631:          CFE_SB_GetAppTskName(TskId,FullName));
        2:  632:      return CFE_SB_BAD_ARGUMENT;
        -:  633:    }/* end if */
        -:  634:
        -:  635:    /* check that the requestor is the owner of the pipe */
      413:  636:    if(CFE_SB.PipeTbl[PipeIdx].AppId != AppId){
        1:  637:      CFE_SB.HKTlmMsg.SubscribeErrCnt++;
        1:  638:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  639:      CFE_EVS_SendEventWithAppID(CFE_SB_SUB_INV_CALLER_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  640:          "Subscribe Err:Caller(%s) is not the owner of pipe %d,Msg=0x%x",
        -:  641:          CFE_SB_GetAppTskName(TskId,FullName),PipeId,MsgId);
        1:  642:      return CFE_SB_BAD_ARGUMENT;
        -:  643:    }/* end if */
        -:  644:
        -:  645:    /* check message id and scope */
      412:  646:    if((CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS)||(Scope > 1))
        -:  647:    {
        1:  648:        CFE_SB.HKTlmMsg.SubscribeErrCnt++;
        1:  649:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  650:        CFE_EVS_SendEventWithAppID(CFE_SB_SUB_ARG_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  651:          "Subscribe Err:Bad Arg,MsgId 0x%x,PipeId %d,app %s,scope %d",
        -:  652:          MsgId,PipeId,CFE_SB_GetAppTskName(TskId,FullName),Scope);
        1:  653:        return CFE_SB_BAD_ARGUMENT;
        -:  654:    }/* end if */
        -:  655:
        -:  656:    /* check for duplicate subscription */
      411:  657:    if(CFE_SB_DuplicateSubscribeCheck(MsgId,PipeId)==CFE_SB_DUPLICATE){
        1:  658:        CFE_SB.HKTlmMsg.DupSubscriptionsCnt++;
        1:  659:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  660:        CFE_EVS_SendEventWithAppID(CFE_SB_DUP_SUBSCRIP_EID,CFE_EVS_INFORMATION,CFE_SB.AppId,
        -:  661:          "Duplicate Subscription,MsgId 0x%x on %s pipe,app %s",
        -:  662:           MsgId,CFE_SB_GetPipeName(PipeId),CFE_SB_GetAppTskName(TskId,FullName));
        1:  663:        return CFE_SUCCESS;
        -:  664:    }/* end if */
        -:  665:
        -:  666:    /*
        -:  667:    ** If there has been a subscription for this message id earlier,
        -:  668:    ** get the element number in the routing table.
        -:  669:    */
      410:  670:    Idx = CFE_SB_GetRoutingTblIdx(MsgId);
        -:  671:
        -:  672:    /* if first subscription for this message... */
      410:  673:    if(Idx==CFE_SB_AVAILABLE){
        -:  674:
        -:  675:        /* Get the index to the first available element in the routing table */
      378:  676:        Idx = CFE_SB_GetAvailRoutingIdx();
        -:  677:
        -:  678:        /* if all routing table elements are used, send event */
      378:  679:        if(Idx >= CFE_SB_MAX_MSG_IDS){
        1:  680:            CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  681:            CFE_EVS_SendEventWithAppID(CFE_SB_MAX_MSGS_MET_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  682:              "Subscribe Err:Max Msgs(%d)In Use,MsgId 0x%x,pipe %s,app %s",
        -:  683:              CFE_SB_MAX_MSG_IDS,MsgId,CFE_SB_GetPipeName(PipeId),CFE_SB_GetAppTskName(TskId,FullName));
        1:  684:            return CFE_SB_MAX_MSGS_MET;
        -:  685:        }/* end if */
        -:  686:
        -:  687:        /* Increment the MsgIds in use ctr and if it's > the high water mark,*/
        -:  688:        /* adjust the high water mark */
      377:  689:        CFE_SB.StatTlmMsg.MsgIdsInUse++;
      377:  690:        if(CFE_SB.StatTlmMsg.MsgIdsInUse > CFE_SB.StatTlmMsg.PeakMsgIdsInUse){
      376:  691:           CFE_SB.StatTlmMsg.PeakMsgIdsInUse = CFE_SB.StatTlmMsg.MsgIdsInUse;
        -:  692:        }/* end if */
        -:  693:
        -:  694:        /* populate the look up table with the routing table index */
      377:  695:        CFE_SB_SetRoutingTblIdx(MsgId,Idx);
        -:  696:
        -:  697:        /* label the new routing block with the message identifier */
      377:  698:        CFE_SB.RoutingTbl[Idx].MsgId = MsgId;
        -:  699:
        -:  700:    }/* end if */
        -:  701:
      409:  702:    if(CFE_SB.RoutingTbl[Idx].Destinations >= CFE_SB_MAX_DEST_PER_PKT){
        1:  703:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  704:        CFE_EVS_SendEventWithAppID(CFE_SB_MAX_DESTS_MET_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  705:            "Subscribe Err:Max Dests(%d)In Use For Msg 0x%x,pipe %s,app %s",
        -:  706:             CFE_SB_MAX_DEST_PER_PKT,MsgId,CFE_SB_GetPipeName(PipeId),
        -:  707:             CFE_SB_GetAppTskName(TskId,FullName));
        1:  708:        return CFE_SB_MAX_DESTS_MET;
        -:  709:    }/* end if */
        -:  710:
      408:  711:    DestBlkPtr = CFE_SB_GetDestinationBlk();
      408:  712:    if(DestBlkPtr == NULL){
        2:  713:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        2:  714:        CFE_EVS_SendEventWithAppID(CFE_SB_DEST_BLK_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  715:            "Subscribe Err:Request for Destination Blk failed for Msg 0x%x",
        -:  716:             CFE_SB_MAX_DEST_PER_PKT,MsgId,CFE_SB_GetPipeName(PipeId),
        -:  717:             CFE_SB_GetAppTskName(TskId,FullName));
        2:  718:        return CFE_SB_BUF_ALOC_ERR;
        -:  719:    }/* end if */
        -:  720:
        -:  721:    /* initialize destination block */
      406:  722:    DestBlkPtr -> PipeId = PipeId;
      406:  723:    DestBlkPtr -> MsgId2PipeLim = (uint16)MsgLim;
      406:  724:    DestBlkPtr -> Active = CFE_SB_ACTIVE;
      406:  725:    DestBlkPtr -> BuffCount = 0;
      406:  726:    DestBlkPtr -> DestCnt = 0;
      406:  727:    DestBlkPtr -> Scope = Scope;
      406:  728:    DestBlkPtr -> Prev = NULL;
      406:  729:    DestBlkPtr -> Next = NULL;
        -:  730:
        -:  731:    /* add destination block to head of list */
      406:  732:    CFE_SB_AddDest(Idx, DestBlkPtr);
        -:  733:
      406:  734:    CFE_SB.RoutingTbl[Idx].Destinations++;
        -:  735:
      406:  736:    CFE_SB.StatTlmMsg.SubscriptionsInUse++;
      406:  737:    if(CFE_SB.StatTlmMsg.SubscriptionsInUse > CFE_SB.StatTlmMsg.PeakSubscriptionsInUse)
        -:  738:    {
      390:  739:       CFE_SB.StatTlmMsg.PeakSubscriptionsInUse = CFE_SB.StatTlmMsg.SubscriptionsInUse;
        -:  740:    }/* end if */
        -:  741:
      406:  742:    if((CFE_SB.SubscriptionReporting == CFE_SB_ENABLE)&&(Scope==CFE_SB_GLOBAL)){
        1:  743:      CFE_SB.SubRprtMsg.MsgId = MsgId;
        1:  744:      CFE_SB.SubRprtMsg.Pipe = PipeId;
        1:  745:      CFE_SB.SubRprtMsg.Qos.Priority = Quality.Priority;
        1:  746:      CFE_SB.SubRprtMsg.Qos.Reliability = Quality.Reliability;
        1:  747:      CFE_SB.SubRprtMsg.SubType = CFE_SB_SUBSCRIPTION;
        1:  748:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  749:      Stat = CFE_SB_SendMsg((CFE_SB_Msg_t *)&CFE_SB.SubRprtMsg);
        1:  750:      CFE_EVS_SendEventWithAppID(CFE_SB_SUBSCRIPTION_RPT_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  751:            "Sending Subscription Report Msg=0x%x,Pipe=%d,Stat=0x%x",
        -:  752:             MsgId,PipeId,Stat);
        1:  753:      CFE_SB_LockSharedData(__func__,__LINE__);/* to prevent back-to-back unlock */
        -:  754:    }/* end if */
        -:  755:
        -:  756:    /* release the semaphore */
      406:  757:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -:  758:
      406:  759:    CFE_EVS_SendEventWithAppID(CFE_SB_SUBSCRIPTION_RCVD_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  760:        "Subscription Rcvd:MsgId 0x%x on %s(%d),app %s",
        -:  761:         MsgId,CFE_SB_GetPipeName(PipeId),PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        -:  762:
      406:  763:    return CFE_SUCCESS;
        -:  764:
        -:  765:}/* end CFE_SB_SubscribeFull */
        -:  766:
        -:  767:
        -:  768:/******************************************************************************
        -:  769:** Name:    CFE_SB_Unsubscribe
        -:  770:**
        -:  771:** Purpose: API used to unsubscribe to a message.
        -:  772:**
        -:  773:** Date Written:
        -:  774:**          04/25/2005
        -:  775:**
        -:  776:** Input Arguments:
        -:  777:**          MsgId
        -:  778:**          PipeId
        -:  779:**
        -:  780:** Output Arguments:
        -:  781:**          None
        -:  782:**
        -:  783:** Return Values:
        -:  784:**          Status
        -:  785:**
        -:  786:******************************************************************************/
        -:  787:int32 CFE_SB_Unsubscribe(CFE_SB_MsgId_t MsgId, CFE_SB_PipeId_t PipeId)
        9:  788:{
        9:  789:    uint32  CallerId = 0xFFFFFFFF;
        9:  790:    int32   Status = 0;
        -:  791:
        -:  792:    /* get the callers Application Id */
        9:  793:    CFE_ES_GetAppID(&CallerId);
        -:  794:
        9:  795:    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, (uint8)CFE_SB_GLOBAL,CallerId);
        -:  796:
        9:  797:    return Status;
        -:  798:
        -:  799:}/* end CFE_SB_Unsubscribe */
        -:  800:
        -:  801:
        -:  802:/******************************************************************************
        -:  803:** Name:    CFE_SB_UnsubscribeLocal
        -:  804:**
        -:  805:** Purpose: CFE Internal API used to locally unsubscribe to a message. This
        -:  806:**          request to cancel a subscription will not be sent to peers.
        -:  807:**
        -:  808:** Date Written:
        -:  809:**          04/25/2005
        -:  810:**
        -:  811:** Input Arguments:
        -:  812:**          MsgId
        -:  813:**          PipeId
        -:  814:**
        -:  815:** Output Arguments:
        -:  816:**          None
        -:  817:**
        -:  818:** Return Values:
        -:  819:**          Status
        -:  820:**
        -:  821:******************************************************************************/
        -:  822:int32 CFE_SB_UnsubscribeLocal(CFE_SB_MsgId_t MsgId, CFE_SB_PipeId_t PipeId)
        1:  823:{
        1:  824:    uint32  CallerId = 0xFFFFFFFF;
        1:  825:    int32   Status = 0;
        -:  826:
        -:  827:    /* get the callers Application Id */
        1:  828:    CFE_ES_GetAppID(&CallerId);
        -:  829:
        1:  830:    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, (uint8)CFE_SB_LOCAL,CallerId);
        -:  831:
        1:  832:    return Status;
        -:  833:
        -:  834:}/* end CFE_SB_UnsubscribeLocal */
        -:  835:
        -:  836:
        -:  837:/******************************************************************************
        -:  838:** Name:    CFE_SB_UnsubscribeAppId
        -:  839:**
        -:  840:** Purpose: CFE Internal API intented to be called by CFE_ES when an applications
        -:  841:**          SB resources need to be freed. The regular unsibscribe api won't work
        -:  842:**          because it does a check to ensure the caller is the owner of the pipe.
        -:  843:**
        -:  844:** Date Written:
        -:  845:**          03/15/2007
        -:  846:**
        -:  847:** Input Arguments:
        -:  848:**          MsgId
        -:  849:**          PipeId
        -:  850:**          AppId
        -:  851:**
        -:  852:** Output Arguments:
        -:  853:**          None
        -:  854:**
        -:  855:** Return Values:
        -:  856:**          Status
        -:  857:**
        -:  858:******************************************************************************/
        -:  859:int32 CFE_SB_UnsubscribeWithAppId(CFE_SB_MsgId_t MsgId,
        -:  860:                              CFE_SB_PipeId_t PipeId,
        -:  861:                              uint32 AppId)
      401:  862:{
      401:  863:    int32   Status = 0;
        -:  864:
      401:  865:    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, (uint8)CFE_SB_LOCAL, AppId);
        -:  866:
      401:  867:    return Status;
        -:  868:
        -:  869:}/* end CFE_SB_UnsubscribeWithAppId */
        -:  870:
        -:  871:
        -:  872:/******************************************************************************
        -:  873:** Name:    CFE_SB_UnsubscribeFull
        -:  874:**
        -:  875:** Purpose: CFE Internal API used to unsubscribe to a message.
        -:  876:**
        -:  877:** Assumptions, External Events, and Notes:
        -:  878:**
        -:  879:**
        -:  880:** Notes:This function cannot be called directly,it would not be semaphore protected.
        -:  881:**       Also,if more than one subscription is found, this function will remove all
        -:  882:**       entries that match.
        -:  883:**
        -:  884:** Date Written:
        -:  885:**          04/25/2005
        -:  886:**
        -:  887:** Input Arguments:
        -:  888:**          MsgId
        -:  889:**          PipeId
        -:  890:**          Scope
        -:  891:**          AppId
        -:  892:**
        -:  893:** Output Arguments:
        -:  894:**          None
        -:  895:**
        -:  896:** Return Values:
        -:  897:**          Status
        -:  898:**
        -:  899:******************************************************************************/
        -:  900:int32 CFE_SB_UnsubscribeFull(CFE_SB_MsgId_t MsgId,CFE_SB_PipeId_t PipeId,
        -:  901:                             uint8 Scope,uint32 AppId)
      411:  902:{
        -:  903:    uint16  Idx;
        -:  904:    uint32  PipeIdx;
      411:  905:    uint32  TskId = 0;
      411:  906:    uint32  MatchFound = FALSE;
        -:  907:    int32   Stat;
      411:  908:    CFE_SB_DestinationD_t   *DestPtr = NULL;
        -:  909:    char    FullName[(OS_MAX_API_NAME * 2)];
        -:  910:
        -:  911:
        -:  912:    /* take semaphore to prevent a task switch during this call */
      411:  913:    CFE_SB_LockSharedData(__func__,__LINE__);
        -:  914:
        -:  915:    /* get task id for events */
      411:  916:    TskId = OS_TaskGetId();
        -:  917:
        -:  918:    /* check that the pipe has been created */
      411:  919:    PipeIdx = CFE_SB_GetPipeIdx(PipeId);
      411:  920:    if(PipeIdx==CFE_SB_INVALID_PIPE){
        1:  921:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  922:      CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_INV_PIPE_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  923:            "Unsubscribe Err:Invalid Pipe Id Msg=0x%x,Pipe=%d,app=%s",
        -:  924:            MsgId,PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        1:  925:      return CFE_SB_BAD_ARGUMENT;
        -:  926:    }/* end if */
        -:  927:
        -:  928:    /* if given 'AppId' is not the owner of the pipe, send error event and return */
      410:  929:    if(CFE_SB.PipeTbl[PipeIdx].AppId != AppId){
        1:  930:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  931:      CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_INV_CALLER_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  932:            "Unsubscribe Err:Caller(%s) is not the owner of pipe %d,Msg=0x%x",
        -:  933:            CFE_SB_GetAppTskName(TskId,FullName),PipeId,MsgId);
        1:  934:      return CFE_SB_BAD_ARGUMENT;
        -:  935:    }/* end if */
        -:  936:
        -:  937:    /* check input parameters */
      409:  938:    if((CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS)||
        -:  939:       (CFE_SB_ValidatePipeId(PipeId) != CFE_SUCCESS)||
        -:  940:       (Scope > 1))
        -:  941:    {
        1:  942:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  943:        CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_ARG_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  944:            "UnSubscribe Err:Bad Arg,MsgId 0x%x,PipeId %d,app %s,scope %d",
        -:  945:            MsgId,PipeId,CFE_SB_GetAppTskName(TskId,FullName),Scope);
        1:  946:        return CFE_SB_BAD_ARGUMENT;
        -:  947:    }/* end if */
        -:  948:
        -:  949:    /* get index into routing table */
      408:  950:    Idx = CFE_SB_GetRoutingTblIdx(MsgId);
        -:  951:
        -:  952:    /* if there are no subscriptions for this message id... */
      408:  953:    if(Idx == CFE_SB_AVAILABLE){
        2:  954:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        2:  955:        CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_NO_SUBS_EID,CFE_EVS_INFORMATION,CFE_SB.AppId,
        -:  956:            "Unsubscribe Err:No subs for Msg 0x%x on %s,app %s",
        -:  957:            MsgId,CFE_SB_GetPipeName(PipeId),CFE_SB_GetAppTskName(TskId,FullName));
        2:  958:        return CFE_SUCCESS;
        -:  959:    }/* end if */
        -:  960:
        -:  961:    /* At this point, there must be at least one destination. */
        -:  962:    /* So the value of 'ListHeadPtr' will not be NULL by design */
        -:  963:
        -:  964:    /* search the list for a matching pipe id */
      406:  965:    DestPtr = CFE_SB.RoutingTbl[Idx].ListHeadPtr;
        -:  966:
        -:  967:    do{
        -:  968:
      544:  969:        if(DestPtr->PipeId == PipeId){
        -:  970:            /* match found, remove node from list */
      406:  971:            CFE_SB_RemoveDest(Idx,DestPtr);
        -:  972:
        -:  973:            /* return node to memory pool */
      406:  974:            CFE_SB_PutDestinationBlk(DestPtr);
        -:  975:
      406:  976:            CFE_SB.RoutingTbl[Idx].Destinations--;
      406:  977:            CFE_SB.StatTlmMsg.SubscriptionsInUse--;
        -:  978:
      406:  979:            MatchFound = TRUE;
        -:  980:
        -:  981:        }/* end if */
        -:  982:
      544:  983:        DestPtr = DestPtr->Next;
        -:  984:
      544:  985:    }while((MatchFound == FALSE)&&(DestPtr != NULL));
        -:  986:
        -:  987:    /* if 'Destinations' was decremented to zero above... */
      406:  988:    if(CFE_SB.RoutingTbl[Idx].Destinations==0){
      375:  989:        CFE_SB.StatTlmMsg.MsgIdsInUse--;
      375:  990:        CFE_SB.RoutingTbl[Idx].MsgId = CFE_SB_INVALID_MSG_ID;
      375:  991:        CFE_SB_SetRoutingTblIdx(MsgId,CFE_SB_AVAILABLE);
        -:  992:
        -:  993:        /* Send unsubscribe report only if there are zero requests for this pkt */
      375:  994:        if((CFE_SB.SubscriptionReporting == CFE_SB_ENABLE)&&
        -:  995:          (Scope == CFE_SB_GLOBAL))
        -:  996:        {
        1:  997:          CFE_SB.SubRprtMsg.MsgId = MsgId;
        1:  998:          CFE_SB.SubRprtMsg.Pipe = PipeId;
        1:  999:          CFE_SB.SubRprtMsg.Qos.Priority = 0;
        1: 1000:          CFE_SB.SubRprtMsg.Qos.Reliability = 0;
        1: 1001:          CFE_SB.SubRprtMsg.SubType = CFE_SB_UNSUBSCRIPTION;
        1: 1002:          CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1003:          Stat = CFE_SB_SendMsg((CFE_SB_Msg_t *)&CFE_SB.SubRprtMsg);
        1: 1004:          CFE_EVS_SendEventWithAppID(CFE_SB_UNSUBSCRIPTION_RPT_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -: 1005:            "Sending Unsubscription Report Msg=0x%x,Pipe=%d,Stat=0x%x",
        -: 1006:            MsgId,PipeId,Stat);
        1: 1007:          CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1008:        }/* end if */
        -: 1009:
        -: 1010:    }/* end if */
        -: 1011:
      406: 1012:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1013:
      406: 1014:    CFE_EVS_SendEventWithAppID(CFE_SB_SUBSCRIPTION_REMOVED_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -: 1015:            "Subscription Removed:Msg 0x%x on pipe %d,app %s",
        -: 1016:            MsgId,PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        -: 1017:
      406: 1018:    return CFE_SUCCESS;
        -: 1019:
        -: 1020:}/* end CFE_SB_UnsubscribeFull */
        -: 1021:
        -: 1022:
        -: 1023:
        -: 1024:/******************************************************************************
        -: 1025:** Name:    CFE_SB_SendMsg
        -: 1026:**
        -: 1027:** Purpose: API used to send a message on the software bus.
        -: 1028:**
        -: 1029:** Assumptions, External Events, and Notes:
        -: 1030:**
        -: 1031:**          Note: This function increments and tracks the source sequence
        -: 1032:**                counter for all telemetry messages.
        -: 1033:**
        -: 1034:** Date Written:
        -: 1035:**          04/25/2005
        -: 1036:**
        -: 1037:** Input Arguments:
        -: 1038:**          MsgPtr
        -: 1039:**
        -: 1040:** Output Arguments:
        -: 1041:**          None
        -: 1042:**
        -: 1043:** Return Values:
        -: 1044:**          Status
        -: 1045:**
        -: 1046:******************************************************************************/
        -: 1047:int32  CFE_SB_SendMsg(CFE_SB_Msg_t    *MsgPtr)
       23: 1048:{
       23: 1049:    int32   Status = 0;
        -: 1050:
       23: 1051:    Status = CFE_SB_SendMsgFull(MsgPtr,CFE_SB_INCREMENT_TLM,CFE_SB_SEND_ONECOPY);
        -: 1052:
       23: 1053:    return Status;
        -: 1054:
        -: 1055:}/* end CFE_SB_SendMsg */
        -: 1056:
        -: 1057:
        -: 1058:
        -: 1059:/******************************************************************************
        -: 1060:** Name:    CFE_SB_PassMsg
        -: 1061:**
        -: 1062:** Purpose: API used to send a message on the software bus.
        -: 1063:**
        -: 1064:** Assumptions, External Events, and Notes:
        -: 1065:**
        -: 1066:**          Note: This function does NOT increment and track the source
        -: 1067:**                sequence counter for telemetry messages.
        -: 1068:**
        -: 1069:** Date Written:
        -: 1070:**          04/25/2005
        -: 1071:**
        -: 1072:** Input Arguments:
        -: 1073:**          MsgPtr
        -: 1074:**
        -: 1075:** Output Arguments:
        -: 1076:**          None
        -: 1077:**
        -: 1078:** Return Values:
        -: 1079:**          Status
        -: 1080:**
        -: 1081:******************************************************************************/
        -: 1082:int32  CFE_SB_PassMsg(CFE_SB_Msg_t    *MsgPtr)
        1: 1083:{
        1: 1084:    int32   Status = 0;
        -: 1085:
        1: 1086:    Status = CFE_SB_SendMsgFull(MsgPtr,CFE_SB_DO_NOT_INCREMENT,CFE_SB_SEND_ONECOPY);
        -: 1087:
        1: 1088:    return Status;
        -: 1089:
        -: 1090:}/* end CFE_SB_PassMsg */
        -: 1091:
        -: 1092:
        -: 1093:
        -: 1094:/******************************************************************************
        -: 1095:** Name:    CFE_SB_SendMsgFull
        -: 1096:**
        -: 1097:** Purpose: API used to send a message on the software bus.
        -: 1098:**
        -: 1099:** Assumptions, External Events, and Notes:
        -: 1100:**
        -: 1101:**          Note: This function increments and tracks the source sequence
        -: 1102:**                counter for all telemetry messages.
        -: 1103:**
        -: 1104:** Date Written:
        -: 1105:**          04/25/2005
        -: 1106:**
        -: 1107:** Input Arguments:
        -: 1108:**          MsgPtr
        -: 1109:**          TlmCntIncrements
        -: 1110:**          CopyMode
        -: 1111:**
        -: 1112:** Output Arguments:
        -: 1113:**          None
        -: 1114:**
        -: 1115:** Return Values:
        -: 1116:**          Status
        -: 1117:**
        -: 1118:******************************************************************************/
        -: 1119:int32  CFE_SB_SendMsgFull(CFE_SB_Msg_t    *MsgPtr,
        -: 1120:                          uint32           TlmCntIncrements,
        -: 1121:                          uint32           CopyMode)
       27: 1122:{
        -: 1123:    CFE_SB_MsgId_t          MsgId;
        -: 1124:    int32                   Status;
       27: 1125:    CFE_SB_DestinationD_t   *DestPtr = NULL;
        -: 1126:    CFE_SB_PipeD_t          *PipeDscPtr;
        -: 1127:    CFE_SB_RouteEntry_t     *RtgTblPtr;
        -: 1128:    CFE_SB_BufferD_t        *BufDscPtr;
        -: 1129:    uint16                  TotalMsgSize;
        -: 1130:    uint16                  RtgTblIdx;
       27: 1131:    uint32                  TskId = 0;
        -: 1132:    uint16                  i;
        -: 1133:    char                    FullName[(OS_MAX_API_NAME * 2)];
        -: 1134:    CFE_SB_EventBuf_t       SBSndErr;
        -: 1135:
       27: 1136:    SBSndErr.EvtsToSnd = 0;
        -: 1137:
        -: 1138:    /* get task id for events and Sender Info*/
       27: 1139:    TskId = OS_TaskGetId();
        -: 1140:
        -: 1141:    /* check input parameter */
       27: 1142:    if(MsgPtr == NULL){
        1: 1143:        CFE_SB_LockSharedData(__func__,__LINE__);
        1: 1144:        CFE_SB.HKTlmMsg.MsgSendErrCnt++;
        1: 1145:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1146:        CFE_EVS_SendEventWithAppID(CFE_SB_SEND_BAD_ARG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1147:            "Send Err:Bad input argument,Arg 0x%x,App %s",
        -: 1148:            (uint32)MsgPtr,CFE_SB_GetAppTskName(TskId,FullName));
        1: 1149:        return CFE_SB_BAD_ARGUMENT;
        -: 1150:    }/* end if */
        -: 1151:
       26: 1152:    MsgId = CFE_SB_GetMsgId(MsgPtr);
        -: 1153:
        -: 1154:    /* validate the msgid in the message */
       26: 1155:    if(CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS){
        1: 1156:        CFE_SB_LockSharedData(__func__,__LINE__);
        1: 1157:        CFE_SB.HKTlmMsg.MsgSendErrCnt++;
        1: 1158:        if (CopyMode == CFE_SB_SEND_ZEROCOPY)
        -: 1159:        {
    #####: 1160:            BufDscPtr = CFE_SB_GetBufferFromCaller(MsgId, MsgPtr);
    #####: 1161:            CFE_SB_DecrBufUseCnt(BufDscPtr);
        -: 1162:        }
        1: 1163:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1164:        CFE_EVS_SendEventWithAppID(CFE_SB_SEND_INV_MSGID_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1165:            "Send Err:Invalid MsgId(0x%x)in msg,App %s",
        -: 1166:            MsgId,CFE_SB_GetAppTskName(TskId,FullName));
        1: 1167:        return CFE_SB_BAD_ARGUMENT;
        -: 1168:    }/* end if */
        -: 1169:
       25: 1170:    TotalMsgSize = CFE_SB_GetTotalMsgLength(MsgPtr);
        -: 1171:
        -: 1172:    /* Verify the size of the pkt is < or = the mission defined max */
       25: 1173:    if(TotalMsgSize > CFE_SB_MAX_SB_MSG_SIZE){
        1: 1174:        CFE_SB_LockSharedData(__func__,__LINE__);
        1: 1175:        CFE_SB.HKTlmMsg.MsgSendErrCnt++;
        1: 1176:        if (CopyMode == CFE_SB_SEND_ZEROCOPY)
        -: 1177:        {
    #####: 1178:            BufDscPtr = CFE_SB_GetBufferFromCaller(MsgId, MsgPtr);
    #####: 1179:            CFE_SB_DecrBufUseCnt(BufDscPtr);
        -: 1180:        }
        1: 1181:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1182:        CFE_EVS_SendEventWithAppID(CFE_SB_MSG_TOO_BIG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1183:            "Send Err:Msg Too Big MsgId=0x%x,app=%s,size=%d,MaxSz=%d",
        -: 1184:            MsgId,CFE_SB_GetAppTskName(TskId,FullName),TotalMsgSize,CFE_SB_MAX_SB_MSG_SIZE);
        1: 1185:        return CFE_SB_MSG_TOO_BIG;
        -: 1186:    }/* end if */
        -: 1187:
        -: 1188:    /* take semaphore to prevent a task switch during this call */
       24: 1189:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1190:
       24: 1191:    RtgTblIdx = CFE_SB_GetRoutingTblIdx(MsgId);
        -: 1192:
        -: 1193:    /* if there have been no subscriptions for this pkt, */
        -: 1194:    /* increment the dropped pkt cnt, send event and return success */
       24: 1195:    if(RtgTblIdx == CFE_SB_AVAILABLE){
        -: 1196:
        9: 1197:        CFE_SB.HKTlmMsg.NoSubscribersCnt++;
        -: 1198:
        9: 1199:        if (CopyMode == CFE_SB_SEND_ZEROCOPY){
    #####: 1200:            BufDscPtr = CFE_SB_GetBufferFromCaller(MsgId, MsgPtr);
    #####: 1201:            CFE_SB_DecrBufUseCnt(BufDscPtr);
        -: 1202:        }
        -: 1203:
        9: 1204:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1205:
        -: 1206:        /* Determine if event can be sent without causing recursive event problem */
        9: 1207:        if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_SEND_NO_SUBS_EID_BIT) == CFE_SB_GRANTED){
        -: 1208:
        9: 1209:           CFE_EVS_SendEventWithAppID(CFE_SB_SEND_NO_SUBS_EID,CFE_EVS_INFORMATION,CFE_SB.AppId,
        -: 1210:              "No subscribers for MsgId 0x%x,sender %s",
        -: 1211:              MsgId,CFE_SB_GetAppTskName(TskId,FullName));
        -: 1212:
        -: 1213:           /* clear the bit so the task may send this event again */
        9: 1214:           CFE_CLR(CFE_SB.StopRecurseFlags[TskId],CFE_SB_SEND_NO_SUBS_EID_BIT);
        -: 1215:        }/* end if */
        -: 1216:
        9: 1217:        return CFE_SUCCESS;
        -: 1218:    }/* end if */
        -: 1219:
        -: 1220:    /* Allocate a new buffer. */
       15: 1221:    if (CopyMode == CFE_SB_SEND_ZEROCOPY){
        3: 1222:        BufDscPtr = CFE_SB_GetBufferFromCaller(MsgId, MsgPtr);
        -: 1223:    }
        -: 1224:    else{
       12: 1225:        BufDscPtr = CFE_SB_GetBufferFromPool(MsgId, TotalMsgSize);
        -: 1226:    }
       15: 1227:    if (BufDscPtr == NULL){
        1: 1228:        CFE_SB.HKTlmMsg.MsgSendErrCnt++;
        1: 1229:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1230:
        -: 1231:        /* Determine if event can be sent without causing recursive event problem */
        1: 1232:        if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_GET_BUF_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1233:
        1: 1234:            CFE_EVS_SendEventWithAppID(CFE_SB_GET_BUF_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1235:              "Send Err:Request for Buffer Failed. MsgId 0x%x,app %s,size %d",
        -: 1236:              MsgId,CFE_SB_GetAppTskName(TskId,FullName),TotalMsgSize);
        -: 1237:
        -: 1238:            /* clear the bit so the task may send this event again */
        1: 1239:            CFE_CLR(CFE_SB.StopRecurseFlags[TskId],CFE_SB_GET_BUF_ERR_EID_BIT);
        -: 1240:        }/* end if */
        -: 1241:
        1: 1242:        return CFE_SB_BUF_ALOC_ERR;
        -: 1243:    }/* end if */
        -: 1244:
        -: 1245:    /* Copy the packet into the SB memory space */
       14: 1246:    if (CopyMode != CFE_SB_SEND_ZEROCOPY){
        -: 1247:        /* Copy the packet into the SB memory space */
       11: 1248:        CFE_PSP_MemCpy( BufDscPtr->Buffer, MsgPtr, (uint16)TotalMsgSize );
        -: 1249:    }
        -: 1250:
        -: 1251:    /* For Tlm packets, increment the seq count if requested */
       14: 1252:    if((CFE_SB_GetPktType(MsgId)==CFE_SB_TLM) &&
        -: 1253:       (TlmCntIncrements==CFE_SB_INCREMENT_TLM)){
       11: 1254:        CFE_SB.RoutingTbl[RtgTblIdx].SeqCnt++;
       11: 1255:        CFE_SB_SetMsgSeqCnt((CFE_SB_Msg_t *)BufDscPtr->Buffer,
        -: 1256:                              CFE_SB.RoutingTbl[RtgTblIdx].SeqCnt);
        -: 1257:    }/* end if */
        -: 1258:
        -: 1259:    /* store the sender information */
       14: 1260:    if(CFE_SB.SenderReporting != 0)
        -: 1261:    {
       14: 1262:       BufDscPtr->Sender.ProcessorId = CFE_PSP_GetProcessorId();
       14: 1263:       strncpy(&BufDscPtr->Sender.AppName[0],CFE_SB_GetAppTskName(TskId,FullName),OS_MAX_API_NAME);
        -: 1264:    }
        -: 1265:
       14: 1266:    RtgTblPtr = &CFE_SB.RoutingTbl[RtgTblIdx];
        -: 1267:
        -: 1268:    /* At this point there must be at least one destination for pkt */
        -: 1269:
       14: 1270:    DestPtr = RtgTblPtr -> ListHeadPtr;
        -: 1271:
        -: 1272:    /* Send the packet to all destinations  */
       28: 1273:    for (i=0; i < RtgTblPtr -> Destinations; i++) {
        -: 1274:
        -: 1275:        /* The DestPtr should never be NULL in this loop, this is just extra
        -: 1276:           protection in case of the unforseen */
       14: 1277:        if(DestPtr == NULL){
    #####: 1278:          break;
        -: 1279:        }
        -: 1280:
       14: 1281:        if (DestPtr->Active == CFE_SB_INACTIVE)    /* destination is inactive */
        -: 1282:        {
        1: 1283:            DestPtr = DestPtr -> Next;
        1: 1284:            continue;
        -: 1285:        }
        -: 1286:
       13: 1287:        PipeDscPtr = &CFE_SB.PipeTbl[DestPtr->PipeId];
        -: 1288:
        -: 1289:        /* if Msg limit exceeded, log event, increment counter */
        -: 1290:        /* and go to next destination */
       13: 1291:        if(DestPtr->BuffCount >= DestPtr->MsgId2PipeLim){
        -: 1292:
        1: 1293:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].PipeId  = DestPtr->PipeId;
        1: 1294:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].EventId = CFE_SB_MSGID_LIM_ERR_EID;
        1: 1295:            SBSndErr.EvtsToSnd++;
        1: 1296:            CFE_SB.HKTlmMsg.MsgLimErrCnt++;
        1: 1297:            PipeDscPtr->SendErrors++;
        1: 1298:            DestPtr = DestPtr -> Next;
        1: 1299:            continue;
        -: 1300:        }
        -: 1301:
        -: 1302:        /*
        -: 1303:        ** Write the buffer descriptor to the queue of the pipe.  If the write
        -: 1304:        ** failed, log info and increment the pipe's error counter.
        -: 1305:        */
       12: 1306:        Status = OS_QueuePut(PipeDscPtr->SysQueueId,(void *)&BufDscPtr,sizeof(CFE_SB_BufferD_t *),0);
        -: 1307:
       12: 1308:        if (Status == OS_SUCCESS) {
       10: 1309:            BufDscPtr->UseCount++;    /* used for releasing buffer  */
       10: 1310:            DestPtr->BuffCount++; /* used for checking MsgId2PipeLimit */
       10: 1311:            DestPtr->DestCnt++;   /* used for statistics */
       10: 1312:            CFE_SB.StatTlmMsg.PipeDepthStats[DestPtr->PipeId].InUse++;
       10: 1313:            if(CFE_SB.StatTlmMsg.PipeDepthStats[DestPtr->PipeId].InUse >
        -: 1314:               CFE_SB.StatTlmMsg.PipeDepthStats[DestPtr->PipeId].PeakInUse){
        8: 1315:                CFE_SB.StatTlmMsg.PipeDepthStats[DestPtr->PipeId].PeakInUse =
        -: 1316:                CFE_SB.StatTlmMsg.PipeDepthStats[DestPtr->PipeId].InUse;
        -: 1317:            }/* end if */
        -: 1318:
        2: 1319:        }else if(Status == OS_QUEUE_FULL) {
        -: 1320:
        1: 1321:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].PipeId  = DestPtr->PipeId;
        1: 1322:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].EventId = CFE_SB_Q_FULL_ERR_EID;
        1: 1323:            SBSndErr.EvtsToSnd++;
        1: 1324:            CFE_SB.HKTlmMsg.PipeOverflowErrCnt++;
        1: 1325:            PipeDscPtr->SendErrors++;
        -: 1326:
        -: 1327:
        -: 1328:        }else{ /* Unexpected error while writing to queue. */
        -: 1329:
        1: 1330:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].PipeId  = DestPtr->PipeId;
        1: 1331:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].EventId = CFE_SB_Q_WR_ERR_EID;
        1: 1332:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].ErrStat = Status;
        1: 1333:            SBSndErr.EvtsToSnd++;
        1: 1334:            CFE_SB.HKTlmMsg.InternalErrCnt++;
        1: 1335:            PipeDscPtr->SendErrors++;
        -: 1336:
        -: 1337:        }/*end if */
        -: 1338:
       12: 1339:        DestPtr = DestPtr -> Next;
        -: 1340:
        -: 1341:    } /* end loop over destinations */
        -: 1342:
        -: 1343:    /*
        -: 1344:    ** Decrement the buffer UseCount and free buffer if cnt=0. This decrement is done
        -: 1345:    ** because the use cnt is initialized to 1 in CFE_SB_GetBufferFromPool.
        -: 1346:    ** Initializing the count to 1 (as opposed to zero) and decrementing it here are
        -: 1347:    ** done to ensure the buffer gets released when there are destinations that have
        -: 1348:    ** been disabled via ground command.
        -: 1349:    */
       14: 1350:    CFE_SB_DecrBufUseCnt(BufDscPtr);
        -: 1351:
        -: 1352:    /* release the semaphore */
       14: 1353:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1354:
        -: 1355:
        -: 1356:    /* send an event for each pipe write error that may have occurred */
       17: 1357:    for(i=0;i < SBSndErr.EvtsToSnd; i++)
        -: 1358:    {
        3: 1359:        if(SBSndErr.EvtBuf[i].EventId == CFE_SB_MSGID_LIM_ERR_EID)
        -: 1360:        {
        -: 1361:            /* Determine if event can be sent without causing recursive event problem */
        1: 1362:            if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_MSGID_LIM_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1363:
        1: 1364:              CFE_ES_PerfLogEntry(CFE_SB_MSG_LIM_PERF_ID);
        1: 1365:              CFE_ES_PerfLogExit(CFE_SB_MSG_LIM_PERF_ID);
        -: 1366:
        1: 1367:              CFE_EVS_SendEventWithAppID(CFE_SB_MSGID_LIM_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1368:                "Msg Limit Err,MsgId 0x%x,pipe %s,sender %s",
        -: 1369:                RtgTblPtr->MsgId,
        -: 1370:                CFE_SB_GetPipeName(SBSndErr.EvtBuf[i].PipeId),
        -: 1371:                CFE_SB_GetAppTskName(TskId,FullName));
        -: 1372:
        -: 1373:              /* clear the bit so the task may send this event again */
        1: 1374:              CFE_CLR(CFE_SB.StopRecurseFlags[TskId],CFE_SB_MSGID_LIM_ERR_EID_BIT);
        -: 1375:            }/* end if */
        -: 1376:
        2: 1377:        }else if(SBSndErr.EvtBuf[i].EventId == CFE_SB_Q_FULL_ERR_EID){
        -: 1378:
        -: 1379:            /* Determine if event can be sent without causing recursive event problem */
        1: 1380:            if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_Q_FULL_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1381:
        1: 1382:              CFE_ES_PerfLogEntry(CFE_SB_PIPE_OFLOW_PERF_ID);
        1: 1383:              CFE_ES_PerfLogExit(CFE_SB_PIPE_OFLOW_PERF_ID);
        -: 1384:
        1: 1385:              CFE_EVS_SendEventWithAppID(CFE_SB_Q_FULL_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1386:                  "Pipe Overflow,MsgId 0x%x,pipe %s,sender %s",
        -: 1387:                  RtgTblPtr->MsgId,
        -: 1388:                  CFE_SB_GetPipeName(SBSndErr.EvtBuf[i].PipeId),
        -: 1389:                  CFE_SB_GetAppTskName(TskId,FullName));
        -: 1390:
        -: 1391:               /* clear the bit so the task may send this event again */
        1: 1392:               CFE_CLR(CFE_SB.StopRecurseFlags[TskId],CFE_SB_Q_FULL_ERR_EID_BIT);
        -: 1393:            }/* end if */
        -: 1394:
        -: 1395:        }else{
        -: 1396:
        -: 1397:            /* Determine if event can be sent without causing recursive event problem */
        1: 1398:            if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_Q_WR_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1399:
        1: 1400:              CFE_EVS_SendEventWithAppID(CFE_SB_Q_WR_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1401:                "Pipe Write Err,MsgId 0x%x,pipe %s,sender %s,stat 0x%x",
        -: 1402:                RtgTblPtr->MsgId,
        -: 1403:                CFE_SB_GetPipeName(SBSndErr.EvtBuf[i].PipeId),
        -: 1404:                CFE_SB_GetAppTskName(TskId,FullName),
        -: 1405:                SBSndErr.EvtBuf[i].ErrStat);
        -: 1406:
        -: 1407:               /* clear the bit so the task may send this event again */
        1: 1408:               CFE_CLR(CFE_SB.StopRecurseFlags[TskId],CFE_SB_Q_WR_ERR_EID_BIT);
        -: 1409:            }/* end if */
        -: 1410:
        -: 1411:        }/* end if */
        -: 1412:    }
        -: 1413:
        -: 1414:
       14: 1415:    return CFE_SUCCESS;
        -: 1416:
        -: 1417:}/* end CFE_SB_SendMsgFull */
        -: 1418:
        -: 1419:
        -: 1420:
        -: 1421:/******************************************************************************
        -: 1422:** Name:    CFE_SB_RcvMsg
        -: 1423:**
        -: 1424:** Purpose: API used to receive a message from the software bus.
        -: 1425:**
        -: 1426:** Assumptions, External Events, and Notes:
        -: 1427:**          Notes:
        -: 1428:**
        -: 1429:**
        -: 1430:** Date Written:
        -: 1431:**          04/25/2005
        -: 1432:**
        -: 1433:** Input Arguments:
        -: 1434:**          PipeId
        -: 1435:**          BufPtr
        -: 1436:**          timeOut - CFE_SB_PEND, CFE_SB_POLL or millisecond timeout
        -: 1437:**
        -: 1438:** Output Arguments:
        -: 1439:**          None
        -: 1440:**
        -: 1441:** Return Values:
        -: 1442:**          Status
        -: 1443:**
        -: 1444:******************************************************************************/
        -: 1445:int32  CFE_SB_RcvMsg(CFE_SB_MsgPtr_t    *BufPtr,
        -: 1446:                     CFE_SB_PipeId_t    PipeId,
        -: 1447:                     int32              TimeOut)
      185: 1448:{
        -: 1449:    int32                  Status;
        -: 1450:    CFE_SB_BufferD_t       *Message;
        -: 1451:    CFE_SB_PipeD_t         *PipeDscPtr;
      185: 1452:    CFE_SB_DestinationD_t  *DestPtr = NULL;
      185: 1453:    uint32                 TskId = 0;
        -: 1454:    char                   FullName[(OS_MAX_API_NAME * 2)];
        -: 1455:
        -: 1456:    /* get task id for events */
      185: 1457:    TskId = OS_TaskGetId();
        -: 1458:
        -: 1459:    /* Check input parameters */
      185: 1460:    if((BufPtr == NULL)||(TimeOut < (-1))){
        1: 1461:        CFE_SB_LockSharedData(__func__,__LINE__);
        1: 1462:        CFE_SB.HKTlmMsg.MsgReceiveErrCnt++;
        1: 1463:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1464:        CFE_EVS_SendEventWithAppID(CFE_SB_RCV_BAD_ARG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1465:            "Rcv Err:Bad Input Arg:BufPtr 0x%x,pipe %d,t/o %d,app %s",
        -: 1466:            (uint32)BufPtr,PipeId,TimeOut,CFE_SB_GetAppTskName(TskId,FullName));
        1: 1467:        return CFE_SB_BAD_ARGUMENT;
        -: 1468:    }/* end if */
        -: 1469:
      184: 1470:    PipeDscPtr = CFE_SB_GetPipePtr(PipeId);
        -: 1471:    /* If the pipe does not exist or PipeId is out of range... */
      184: 1472:    if (PipeDscPtr == NULL) {
        1: 1473:        CFE_SB_LockSharedData(__func__,__LINE__);
        1: 1474:        CFE_SB.HKTlmMsg.MsgReceiveErrCnt++;
        1: 1475:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1476:        CFE_EVS_SendEventWithAppID(CFE_SB_BAD_PIPEID_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1477:            "Rcv Err:PipeId %d does not exist,app %s",
        -: 1478:            PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        1: 1479:        return CFE_SB_BAD_ARGUMENT;
        -: 1480:    }/* end if */
        -: 1481:
        -: 1482:    /*
        -: 1483:    ** Save off any currently in use buffer to free later; this allows
        -: 1484:    ** one fewer shared data locks
        -: 1485:    */
        -: 1486:
      183: 1487:    PipeDscPtr->ToTrashBuff = PipeDscPtr->CurrentBuff;
      183: 1488:    PipeDscPtr->CurrentBuff = NULL;
        -: 1489:
        -: 1490:    /*
        -: 1491:    ** Read a new buffer from the queue of the pipe, using the
        -: 1492:    ** specified timeout option.  If a buffer was obtained, return the
        -: 1493:    ** packet to the task according to mode.  Otherwise, return a status
        -: 1494:    ** code indicating that no buffer was read.
        -: 1495:    */
      183: 1496:    Status = CFE_SB_ReadQueue(PipeDscPtr, TskId, TimeOut, &Message);
        -: 1497:
        -: 1498:    /* take semaphore again to protect the remaining code in this call */
      183: 1499:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1500:
        -: 1501:    /* free any pending trash buffer */
      183: 1502:    if (PipeDscPtr->ToTrashBuff != NULL) {
        -: 1503:
        -: 1504:        /* Decrement the Buffer Use Count and Free buffer if cnt=0) */
        9: 1505:        CFE_SB_DecrBufUseCnt(PipeDscPtr->ToTrashBuff);
        -: 1506:
        9: 1507:        PipeDscPtr->ToTrashBuff = NULL;
        -: 1508:
        -: 1509:    }/* end if */
        -: 1510:
      183: 1511:    if (Status == CFE_SUCCESS) {
        -: 1512:
        -: 1513:        /*
        -: 1514:        ** Load the pipe tables 'CurrentBuff' with the buffer descriptor
        -: 1515:        ** ptr corresponding to the message just read. This is done so that
        -: 1516:        ** the buffer can be released on the next RcvMsg call for this pipe.
        -: 1517:        */
       10: 1518:        PipeDscPtr->CurrentBuff = Message;
        -: 1519:
        -: 1520:        /* Set the Receivers pointer to the address of the actual message */
       10: 1521:        *BufPtr = (CFE_SB_MsgPtr_t) Message->Buffer;
        -: 1522:
        -: 1523:        /* get pointer to destination to be used in decrementing msg limit cnt*/
       10: 1524:        DestPtr = CFE_SB_GetDestPtr(PipeDscPtr->CurrentBuff->MsgId, PipeDscPtr->PipeId);
        -: 1525:
        -: 1526:        /*
        -: 1527:        ** DestPtr would be NULL if the msg is unsubscribed to while it is on
        -: 1528:        ** the pipe. The BuffCount may be zero if the msg is unsubscribed to and
        -: 1529:        ** then resubscribed to while it is on the pipe. Both of these cases are
        -: 1530:        ** considered nominal and are handled by the code below.
        -: 1531:        */
       10: 1532:        if(DestPtr != NULL){
        -: 1533:
        6: 1534:            if (DestPtr->BuffCount > 0){
        6: 1535:                DestPtr->BuffCount--;
        -: 1536:            }
        -: 1537:
        -: 1538:        }/* end if DestPtr != NULL */
        -: 1539:
       10: 1540:        CFE_SB.StatTlmMsg.PipeDepthStats[PipeDscPtr->PipeId].InUse--;
        -: 1541:
        -: 1542:    }else{
        -: 1543:
        -: 1544:        /* Set the users pointer to NULL indicating the CFE_SB_ReadQueue failed */
      173: 1545:        *BufPtr = NULL;
        -: 1546:
        -: 1547:    }/* end if */
        -: 1548:
        -: 1549:    /* release the semaphore */
      183: 1550:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1551:
        -: 1552:    /*
        -: 1553:    ** If status is not CFE_SUCCESS, then no packet was received.  If this was
        -: 1554:    ** caused by an unexpected error, then CFE_SB_ReadQueue() will report the
        -: 1555:    ** error.
        -: 1556:    */
      183: 1557:    return Status;
        -: 1558:
        -: 1559:}/* end CFE_SB_RcvMsg */
        -: 1560:
        -: 1561:
        -: 1562:/******************************************************************************
        -: 1563:** Name:    CFE_SB_GetLastSenderId
        -: 1564:**
        -: 1565:** Purpose: API used for receiving sender Information of the last message received on
        -: 1566:**          the given pipe.
        -: 1567:**
        -: 1568:** Assumptions, External Events, and Notes:
        -: 1569:**          None
        -: 1570:**
        -: 1571:** Date Written:
        -: 1572:**          06/13/2007
        -: 1573:**
        -: 1574:** Input Arguments:
        -: 1575:**          Ptr -     caller declares a ptr of type CFE_SB_SenderId_t then gives the
        -: 1576:**                    address of that pointer.
        -: 1577:**          PipeId -  the Pipe Id that the message was received on.
        -: 1578:**
        -: 1579:** Output Arguments:
        -: 1580:**          None
        -: 1581:**
        -: 1582:** Return Values:
        -: 1583:**          Status
        -: 1584:**
        -: 1585:******************************************************************************/
        -: 1586:uint32  CFE_SB_GetLastSenderId(CFE_SB_SenderId_t **Ptr,CFE_SB_PipeId_t  PipeId)
        4: 1587:{
        -: 1588:
        -: 1589:    CFE_SB_BufferD_t *Ptr2BufDescriptor;
        4: 1590:    uint32            TskId = 0;
        4: 1591:    uint32            AppId = 0xFFFFFFFF;
        -: 1592:    char              FullName[(OS_MAX_API_NAME * 2)];
        -: 1593:
        4: 1594:    TskId = OS_TaskGetId();
        -: 1595:
        -: 1596:    /* validate ptr  - note: must validate ptr before pipe id validation  */
        -: 1597:    /* because an invalid pipe id sets the callers pointer to NULL */
        4: 1598:    if(Ptr == NULL){
        1: 1599:      CFE_EVS_SendEventWithAppID(CFE_SB_LSTSNDER_ERR1_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1600:          "SB GetLastSender Err:Rcvd Null Ptr,Pipe=%d,App=%s",
        -: 1601:          PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        1: 1602:      return CFE_SB_BAD_ARGUMENT;
        -: 1603:    }/* end if */
        -: 1604:
        -: 1605:    /* validate pipe id */
        3: 1606:    if(CFE_SB_ValidatePipeId(PipeId)!=CFE_SUCCESS){
        1: 1607:      *Ptr = NULL;
        1: 1608:      CFE_EVS_SendEventWithAppID(CFE_SB_LSTSNDER_ERR2_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1609:          "SB GetLastSender Err:Rcvd Invalid Pipe=%d,App=%s",
        -: 1610:          PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        1: 1611:      return CFE_SB_BAD_ARGUMENT;
        -: 1612:    }/* end if */
        -: 1613:
        2: 1614:    CFE_ES_GetAppID(&AppId);
        -: 1615:
        2: 1616:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1617:
        -: 1618:    /* verify requestor is owner of pipe */
        2: 1619:    if(CFE_SB.PipeTbl[PipeId].AppId != AppId){
        1: 1620:      *Ptr = NULL;
        1: 1621:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1622:      CFE_EVS_SendEventWithAppID(CFE_SB_GLS_INV_CALLER_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1623:          "SB GetLastSender Err:Caller(%s) is not the owner of pipe %d",
        -: 1624:          CFE_SB_GetAppTskName(TskId,FullName),PipeId);
        1: 1625:      return CFE_SB_BAD_ARGUMENT;
        -: 1626:    }/* end if */
        -: 1627:
        -: 1628:    /* Get ptr to buffer descriptor for the last msg received on the given pipe */
        1: 1629:    Ptr2BufDescriptor = CFE_SB.PipeTbl[PipeId].CurrentBuff;
        -: 1630:
        -: 1631:    /* Set the receivers pointer to the adr of 'Sender' struct in buf descriptor */
        1: 1632:    *Ptr = (CFE_SB_SenderId_t *) &Ptr2BufDescriptor -> Sender;
        -: 1633:
        1: 1634:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1635:
        1: 1636:    return CFE_SUCCESS;
        -: 1637:
        -: 1638:}/* end CFE_SB_GetLastSenderId */
        -: 1639:
        -: 1640:
        -: 1641:/******************************************************************************
        -: 1642:** Name:    CFE_SB_ZeroCopyGetPtr
        -: 1643:**
        -: 1644:** Purpose: API used for for getting a pointer to a buffer (for zero copy mode
        -: 1645:**          only)
        -: 1646:**
        -: 1647:** Assumptions, External Events, and Notes:
        -: 1648:**          None
        -: 1649:**
        -: 1650:** Date Written:
        -: 1651:**          04/25/2005
        -: 1652:**
        -: 1653:** Input Arguments:
        -: 1654:**          MsgSize
        -: 1655:**
        -: 1656:** Output Arguments:
        -: 1657:**          BufferHandle
        -: 1658:**
        -: 1659:** Return Values:
        -: 1660:**          Pointer to an empty buffer in SB Memory space, or NULL if the buffer
        -: 1661:**          could not be allocated.
        -: 1662:**
        -: 1663:******************************************************************************/
        -: 1664:
        -: 1665:CFE_SB_Msg_t  *CFE_SB_ZeroCopyGetPtr(uint16 MsgSize,
        -: 1666:                                     CFE_SB_ZeroCopyHandle_t *BufferHandle)
        9: 1667:{
        -: 1668:   int32                stat1;
        9: 1669:   uint32               AppId = 0xFFFFFFFF;
        9: 1670:   uint8               *address = NULL;
        9: 1671:   CFE_SB_ZeroCopyD_t  *zcd = NULL;
        9: 1672:   CFE_SB_BufferD_t    *bd = NULL;
        -: 1673:
        9: 1674:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1675:
        -: 1676:    /* Allocate a new zero copy descriptor from the SB memory pool.*/
        9: 1677:    stat1 = CFE_ES_GetPoolBuf((uint32 **)&zcd, CFE_SB.Mem.PoolHdl,  sizeof(CFE_SB_ZeroCopyD_t));
        9: 1678:    if(stat1 < 0){
        1: 1679:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1680:        return NULL;
        -: 1681:    }
        -: 1682:
        -: 1683:    /* Add the size of a zero copy descriptor to the memory-in-use ctr and */
        -: 1684:    /* adjust the high water mark if needed */
        8: 1685:    CFE_SB.StatTlmMsg.MemInUse+=stat1;
        8: 1686:    if(CFE_SB.StatTlmMsg.MemInUse > CFE_SB.StatTlmMsg.PeakMemInUse){
        8: 1687:       CFE_SB.StatTlmMsg.PeakMemInUse = CFE_SB.StatTlmMsg.MemInUse;
        -: 1688:    }/* end if */
        -: 1689:
        -: 1690:    /* Allocate a new buffer (from the SB memory pool) to hold the message  */
        8: 1691:    stat1 = CFE_ES_GetPoolBuf((uint32 **)&bd, CFE_SB.Mem.PoolHdl, MsgSize + sizeof(CFE_SB_BufferD_t));
        8: 1692:    if((stat1 < 0)||(bd==NULL)){
        -: 1693:        /*deallocate the first buffer if the second buffer creation fails*/
        1: 1694:        stat1 = CFE_ES_PutPoolBuf(CFE_SB.Mem.PoolHdl, (uint32 *)zcd);
        1: 1695:        if(stat1 > 0){
        1: 1696:            CFE_SB.StatTlmMsg.MemInUse-=stat1;
        -: 1697:        }
        1: 1698:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1699:        return NULL;
        -: 1700:    }
        -: 1701:
        -: 1702:    /* Increment the number of buffers in use by one even though two buffers */
        -: 1703:    /* were allocated. SBBuffersInUse increments on a per-message basis */
        7: 1704:    CFE_SB.StatTlmMsg.SBBuffersInUse++;
        7: 1705:    if(CFE_SB.StatTlmMsg.SBBuffersInUse > CFE_SB.StatTlmMsg.PeakSBBuffersInUse){
        7: 1706:        CFE_SB.StatTlmMsg.PeakSBBuffersInUse = CFE_SB.StatTlmMsg.SBBuffersInUse;
        -: 1707:    }/* end if */
        -: 1708:
        -: 1709:    /* Add the size of the actual buffer to the memory-in-use ctr and */
        -: 1710:    /* adjust the high water mark if needed */
        7: 1711:    CFE_SB.StatTlmMsg.MemInUse+=stat1;
        7: 1712:    if(CFE_SB.StatTlmMsg.MemInUse > CFE_SB.StatTlmMsg.PeakMemInUse){
        7: 1713:       CFE_SB.StatTlmMsg.PeakMemInUse = CFE_SB.StatTlmMsg.MemInUse;
        -: 1714:    }/* end if */
        -: 1715:
        -: 1716:    /* first set ptr to actual msg buffer the same as ptr to descriptor */
        7: 1717:    address = (uint8 *)bd;
        -: 1718:
        -: 1719:    /* increment actual msg buffer ptr beyond the descriptor */
        7: 1720:    address += sizeof(CFE_SB_BufferD_t);
        -: 1721:
        -: 1722:    /* Initialize the zero copy descriptor structure. */
        7: 1723:    zcd->Size      = MsgSize;
        7: 1724:    zcd->Buffer    = (void *)address;
        7: 1725:    zcd->Next      = NULL;
        -: 1726:
        -: 1727:    /* Add this Zero Copy Descriptor to the end of the chain */
        7: 1728:    if(CFE_SB.ZeroCopyTail != NULL){
        3: 1729:        ((CFE_SB_ZeroCopyD_t *) CFE_SB.ZeroCopyTail)->Next = (void *)zcd;
        -: 1730:    }
        7: 1731:    zcd->Prev = CFE_SB.ZeroCopyTail;
        7: 1732:    CFE_SB.ZeroCopyTail = (void *)zcd;
        -: 1733:
        7: 1734:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1735:
        -: 1736:    /* get callers AppId */
        7: 1737:    CFE_ES_GetAppID(&AppId);
        7: 1738:    zcd->AppID     = AppId;
        -: 1739:
        7: 1740:    (*BufferHandle) = (CFE_SB_ZeroCopyHandle_t) zcd;
        -: 1741:
        -: 1742:    /* Initialize the buffer descriptor structure. */
        7: 1743:    bd->UseCount  = 1;
        7: 1744:    bd->Size      = MsgSize;
        7: 1745:    bd->Buffer    = (void *)address;
        -: 1746:
        7: 1747:    return (CFE_SB_Msg_t *)address;
        -: 1748:
        -: 1749:}/* CFE_SB_ZeroCopyGetPtr */
        -: 1750:
        -: 1751:
        -: 1752:/******************************************************************************
        -: 1753:** Name:    CFE_SB_ZeroCopyReleasePtr
        -: 1754:**
        -: 1755:** Purpose: API used for releasing a pointer to a buffer (for zero copy mode
        -: 1756:**          only) This function is typically not needed for zero copy transfers.
        -: 1757:**          This function is needed only when a ptr is received via
        -: 1758:**          CFE_SB_ZeroCopyGetPtr, but never used in a send.
        -: 1759:**
        -: 1760:** Assumptions, External Events, and Notes:
        -: 1761:**          None
        -: 1762:**
        -: 1763:** Date Written:
        -: 1764:**          04/25/2005
        -: 1765:**
        -: 1766:** Input Arguments:
        -: 1767:**          Ptr2Release
        -: 1768:**          BufferHandle
        -: 1769:**
        -: 1770:** Output Arguments:
        -: 1771:**          None
        -: 1772:**
        -: 1773:** Return Values:
        -: 1774:**          Status
        -: 1775:**
        -: 1776:******************************************************************************/
        -: 1777:int32 CFE_SB_ZeroCopyReleasePtr(CFE_SB_Msg_t  *Ptr2Release,
        -: 1778:                                CFE_SB_ZeroCopyHandle_t BufferHandle)
        6: 1779:{
        -: 1780:    int32    Status;
        -: 1781:    int32    Stat2;
        -: 1782:
        6: 1783:    Status = CFE_SB_ZeroCopyReleaseDesc(Ptr2Release, BufferHandle);
        -: 1784:
        6: 1785:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1786:
        6: 1787:    if(Status == CFE_SUCCESS){
        -: 1788:        /* give the buffer back to the buffer pool */
        5: 1789:        Stat2 = CFE_ES_PutPoolBuf(CFE_SB.Mem.PoolHdl,
        -: 1790:                                  (uint32 *) (((uint8 *)Ptr2Release) - sizeof(CFE_SB_BufferD_t)));
        5: 1791:        if(Stat2 > 0){
        -: 1792:             /* Substract the size of the actual buffer from the Memory in use ctr */
        5: 1793:            CFE_SB.StatTlmMsg.MemInUse-=Stat2;
        5: 1794:            CFE_SB.StatTlmMsg.SBBuffersInUse--;
        -: 1795:        }/* end if */
        -: 1796:    }
        -: 1797:
        6: 1798:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1799:
        6: 1800:    return Status;
        -: 1801:
        -: 1802:}/* end CFE_SB_ZeroCopyReleasePtr */
        -: 1803:
        -: 1804:
        -: 1805:/******************************************************************************
        -: 1806:** Name:    CFE_SB_ZeroCopyReleaseDesc
        -: 1807:**
        -: 1808:** Purpose: API used for releasing a zero copy descriptor (for zero copy mode
        -: 1809:**          only).
        -: 1810:**
        -: 1811:** Assumptions, External Events, and Notes:
        -: 1812:**          None
        -: 1813:**
        -: 1814:** Date Written:
        -: 1815:**          04/25/2005
        -: 1816:**
        -: 1817:** Input Arguments:
        -: 1818:**          Ptr2Release
        -: 1819:**          BufferHandle
        -: 1820:**
        -: 1821:** Output Arguments:
        -: 1822:**          None
        -: 1823:**
        -: 1824:** Return Values:
        -: 1825:**          Status
        -: 1826:**
        -: 1827:******************************************************************************/
        -: 1828:int32 CFE_SB_ZeroCopyReleaseDesc(CFE_SB_Msg_t  *Ptr2Release,
        -: 1829:                                 CFE_SB_ZeroCopyHandle_t  BufferHandle)
        8: 1830:{
        -: 1831:    int32    Stat;
        8: 1832:    CFE_SB_ZeroCopyD_t *zcd = (CFE_SB_ZeroCopyD_t *) BufferHandle;
        -: 1833:
        8: 1834:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1835:
        8: 1836:    Stat = CFE_ES_GetPoolBufInfo(CFE_SB.Mem.PoolHdl, (uint32 *)zcd);
        -: 1837:
        8: 1838:    if((Ptr2Release == NULL) || (Stat < 0) || (zcd->Buffer != (void *)Ptr2Release)){
        1: 1839:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1840:        return CFE_SB_BUFFER_INVALID;
        -: 1841:    }
        -: 1842:
        -: 1843:    /* delink the descriptor */
        7: 1844:    if(zcd->Prev != NULL){
        3: 1845:        ((CFE_SB_ZeroCopyD_t *) (zcd->Prev))->Next = zcd->Next;
        -: 1846:    }
        7: 1847:    if(zcd->Next != NULL){
        1: 1848:        ((CFE_SB_ZeroCopyD_t *) (zcd->Next))->Prev = zcd->Prev;
        -: 1849:    }
        7: 1850:    if(CFE_SB.ZeroCopyTail == (void *)zcd){
        6: 1851:        CFE_SB.ZeroCopyTail = zcd->Prev;
        -: 1852:    }
        -: 1853:
        -: 1854:    /* give the descriptor back to the buffer pool */
        7: 1855:    Stat = CFE_ES_PutPoolBuf(CFE_SB.Mem.PoolHdl, (uint32 *)zcd);
        7: 1856:    if(Stat > 0){
        -: 1857:        /* Substract the size of the actual buffer from the Memory in use ctr */
        7: 1858:        CFE_SB.StatTlmMsg.MemInUse-=Stat;
        -: 1859:    }/* end if */
        -: 1860:
        7: 1861:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1862:
        7: 1863:    return CFE_SUCCESS;
        -: 1864:
        -: 1865:}/* end CFE_SB_ZeroCopyReleaseDesc */
        -: 1866:
        -: 1867:
        -: 1868:/******************************************************************************
        -: 1869:** Name:    CFE_SB_ZeroCopySend
        -: 1870:**
        -: 1871:** Purpose: API for sending messages in zero copy mode (with telemetry source
        -: 1872:**          sequence count incrementing)
        -: 1873:**
        -: 1874:** Assumptions, External Events, and Notes:
        -: 1875:**          None
        -: 1876:**
        -: 1877:** Date Written:
        -: 1878:**          04/25/2005
        -: 1879:**
        -: 1880:** Input Arguments:
        -: 1881:**          MsgPtr - Pointer to message to be sent
        -: 1882:**          BufferHandle - Handle supplied by the get pointer call
        -: 1883:**
        -: 1884:** Output Arguments:
        -: 1885:**          None
        -: 1886:**
        -: 1887:** Return Values:
        -: 1888:**          Status
        -: 1889:**
        -: 1890:******************************************************************************/
        -: 1891:int32 CFE_SB_ZeroCopySend(CFE_SB_Msg_t   *MsgPtr,
        -: 1892:                          CFE_SB_ZeroCopyHandle_t BufferHandle)
        1: 1893:{
        1: 1894:    int32   Status = 0;
        -: 1895:
        1: 1896:    Status = CFE_SB_ZeroCopyReleaseDesc(MsgPtr, BufferHandle);
        -: 1897:
        1: 1898:    if(Status == CFE_SUCCESS){
        1: 1899:        Status = CFE_SB_SendMsgFull(MsgPtr,CFE_SB_INCREMENT_TLM,CFE_SB_SEND_ZEROCOPY);
        -: 1900:    }
        -: 1901:
        1: 1902:    return Status;
        -: 1903:
        -: 1904:}/* end CFE_SB_ZeroCopySend */
        -: 1905:
        -: 1906:
        -: 1907:/******************************************************************************
        -: 1908:** Name:    CFE_SB_ZeroCopyPass
        -: 1909:**
        -: 1910:** Purpose: API for sending messages in zero copy mode (telemetry source
        -: 1911:**          sequence count is preserved)
        -: 1912:**
        -: 1913:** Assumptions, External Events, and Notes:
        -: 1914:**          None
        -: 1915:**
        -: 1916:** Date Written:
        -: 1917:**          04/25/2005
        -: 1918:**
        -: 1919:** Input Arguments:
        -: 1920:**          MsgPtr - Pointer to message to be sent
        -: 1921:**          BufferHandle - Handle supplied by the get pointer call
        -: 1922:**
        -: 1923:** Output Arguments:
        -: 1924:**          None
        -: 1925:**
        -: 1926:** Return Values:
        -: 1927:**          Status
        -: 1928:**
        -: 1929:******************************************************************************/
        -: 1930:int32 CFE_SB_ZeroCopyPass(CFE_SB_Msg_t   *MsgPtr,
        -: 1931:                          CFE_SB_ZeroCopyHandle_t BufferHandle)
        1: 1932:{
        1: 1933:    int32   Status = 0;
        -: 1934:
        1: 1935:    Status = CFE_SB_ZeroCopyReleaseDesc(MsgPtr, BufferHandle);
        -: 1936:
        1: 1937:    if(Status == CFE_SUCCESS){
        1: 1938:        Status = CFE_SB_SendMsgFull(MsgPtr,CFE_SB_DO_NOT_INCREMENT,CFE_SB_SEND_ZEROCOPY);
        -: 1939:    }
        -: 1940:
        1: 1941:    return Status;
        -: 1942:
        -: 1943:}/* end CFE_SB_ZeroCopyPass */
        -: 1944:
        -: 1945:
        -: 1946:/******************************************************************************
        -: 1947:**  Function:  CFE_SB_ReadQueue()
        -: 1948:**
        -: 1949:**  Purpose:
        -: 1950:**    Read an SB message from the system queue.  The message is represented
        -: 1951:**    by a pointer to the buffer descriptor of the message.  Several options
        -: 1952:**    are available for the timeout, as described below.
        -: 1953:**
        -: 1954:**  Arguments:
        -: 1955:**    PipeDscPtr: Pointer to pipe descriptor.
        -: 1956:**    AppId     : Application ID of the receiving task (used for error messages).
        -: 1957:**    Time_Out  : Timeout option; one of the following:
        -: 1958:**                  CFE_SB_PEND_FOREVER  = wait forever until a packet arrives
        -: 1959:**                  CFE_SB_POLL = check the pipe for packets but don't wait
        -: 1960:**                  value in milliseconds = wait up to a specified time
        -: 1961:**    Message   : Pointer to a variable that will receive the buffer
        -: 1962:**                descriptor of the message.
        -: 1963:**
        -: 1964:**  Return:
        -: 1965:**    CFE_SB status code indicating the result of the operation:
        -: 1966:**      CFE_SUCCESS         = message was successfully read
        -: 1967:**      CFE_SB_NO_MESSAGE   = no message is present (for CFE_SB_POLL option)
        -: 1968:**      CFE_SB_TIME_OUT     = timeout expired (for timeout option)
        -: 1969:**      CFE_SB_PIPE_RD_ERR  = an unexpected queue read error occurred
        -: 1970:*/
        -: 1971:
        -: 1972:int32  CFE_SB_ReadQueue (CFE_SB_PipeD_t         *PipeDscPtr,
        -: 1973:                         uint32                 TskId,
        -: 1974:                         CFE_SB_TimeOut_t       Time_Out,
        -: 1975:                         CFE_SB_BufferD_t       **Message)
      183: 1976:{
        -: 1977:    int32              Status,TimeOut;
        -: 1978:    uint32             Nbytes;
        -: 1979:    char               FullName[(OS_MAX_API_NAME * 2)];
        -: 1980:
        -: 1981:    /* translate the given Time_Out value */
      183: 1982:    switch(Time_Out){
        -: 1983:
        -: 1984:      case CFE_SB_PEND_FOREVER:
        8: 1985:          TimeOut = OS_PEND;
        8: 1986:          break;
        -: 1987:
        -: 1988:      case CFE_SB_POLL:
      174: 1989:          TimeOut = OS_CHECK;
      174: 1990:          break;
        -: 1991:
        -: 1992:      default:
        1: 1993:          TimeOut = Time_Out;
        -: 1994:          break;
        -: 1995:
        -: 1996:    }/* end switch */
        -: 1997:
        -: 1998:    /* Read the buffer descriptor address from the queue.  */
      183: 1999:    Status = OS_QueueGet(PipeDscPtr->SysQueueId,
        -: 2000:                        (void *)Message,
        -: 2001:                        sizeof(CFE_SB_BufferD_t *),
        -: 2002:                        &Nbytes,
        -: 2003:                        TimeOut);
        -: 2004:
        -: 2005:    /* translate the return value */
      183: 2006:    switch(Status){
        -: 2007:
        -: 2008:      case OS_SUCCESS:
       10: 2009:          return CFE_SUCCESS;
        -: 2010:          break;
        -: 2011:
        -: 2012:      case OS_QUEUE_EMPTY:
      170: 2013:          return CFE_SB_NO_MESSAGE;
        -: 2014:          break;
        -: 2015:
        -: 2016:      case OS_QUEUE_TIMEOUT:
        1: 2017:          return CFE_SB_TIME_OUT;
        -: 2018:          break;
        -: 2019:
        -: 2020:      default:
        2: 2021:          CFE_SB_LockSharedData(__func__,__LINE__);
        2: 2022:          CFE_SB.HKTlmMsg.InternalErrCnt++;
        2: 2023:          CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 2024:          /* Unexpected error while reading the queue. */
        2: 2025:          CFE_EVS_SendEventWithAppID(CFE_SB_Q_RD_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 2026:              "Pipe Read Err,pipe %s,app %s,stat 0x%x",
        -: 2027:              CFE_SB_GetPipeName(PipeDscPtr->PipeId),CFE_SB_GetAppTskName(TskId,FullName),Status);
        -: 2028:
        2: 2029:          return CFE_SB_PIPE_RD_ERR;
        -: 2030:          break;
        -: 2031:
        -: 2032:    }/* end switch */
        -: 2033:
        -: 2034:}/* end CFE_SB_ReadQueue */
        -: 2035:
        -: 2036:/*****************************************************************************/
        -: 2037:
